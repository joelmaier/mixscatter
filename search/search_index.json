{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to mixscatter","text":"<p>mixscatter is a versatile tool for calculating scattering  functions of particle mixtures, particularly for small-angle scattering (SAS) or static and dynamic light scattering (SLS &amp; DLS) applications.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Scattering Functions: Calculate scattering amplitudes, measurable intensities, form factors,   structure factors and diffusion coefficients for multi-component mixtures.</li> <li>Flexible Mixture Composition: Define particle mixtures with arbitrary compositions and complex    scattering length density profiles.</li> <li>Advanced Models: Use predefined scattering models or build entirely custom particles with the    powerful <code>ParticleBuilder</code>.</li> </ul>"},{"location":"#background","title":"Background","text":"<p>Understanding the principles behind scattering techniques is crucial for interpreting experimental  data accurately. mixscatter provides tools to analyze systems of interacting spherical  scatterers in the Born approximation (Rayleigh-Gans-Debye scattering). Very basic information and a couple of equations for the interested reader are given in the  Background page of this documentation.</p> <p>Here are some useful references:</p> <ul> <li>P. Salgi and R. Rajagopalan, \"Polydispersity in colloids: implications to static structure and    scattering\", Adv. Colloid Interface Sci. 43, 169-288 (1993)</li> <li>A. Vrij, \"Mixtures of hard spheres in the Percus\u2013Yevick approximation. Light scattering at     finite angles\",  J. Chem. Phys. 71, 3267-3270 (1979)</li> <li>R. Botet, S. Kwok and B. Cabane, \"Percus-Yevick structure factors made simple\",     J. Appl. Cryst. 53, 1570-1582 (2020)</li> <li>J. Diaz Maier, K. Gaus and J. Wagner, \"Measurable structure factors of dense dispersions     containing polydisperse, optically inhomogeneous particles\",     arXiv:2404.03470 [cond-mat.soft]</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>mixscatter is available at the Python Package Index (PyPI). You can install the package via <code>pip</code>: <pre><code>pip install mixscatter\n</code></pre> The source code is currently hosted on GitHub at: https://github.com/joelmaier/mixscatter</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For detailed instructions on how to use mixscatter, refer to the  Getting Started Guide.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Explore detailed information on all functions, classes, and modules in the  API Reference.</p>"},{"location":"background/","title":"Background","text":"<p>Most of this information can be found in more detail in the work of  P. Salgi and R. Rajagopalan, \"Polydispersity in colloids: implications to  static structure and scattering\", Adv. Colloid Interface Sci. 43, 169-288 (1993). A basic understanding of the principles of  small-angle scattering and  light scattering by particles is recommended.</p>"},{"location":"background/#definitions-and-naming-conventions","title":"Definitions and Naming Conventions","text":"<p>The scattered intensity \\(I(Q)\\) in dependence of the scattering wavevector \\(Q\\) of a multicomponent system of spherical particles with \\(n\\) distinct species can be written as</p> \\[ I(Q) \\propto \\sum_{\\alpha, \\beta=1}^{n} (x_\\alpha x_\\beta)^{1/2} \\,     F_\\alpha(Q) \\, F_\\beta(Q) \\, S_{\\alpha \\beta}(Q), \\] <p>where \\(x_\\alpha\\) is the number fraction of the species \\(\\alpha\\).</p> <p>The scattering amplitude \\(F_\\alpha(Q)\\) of the species \\(\\alpha\\) is the Fourier transform of the scattering contrast \\(\\Delta\\rho_\\alpha(r)\\) of the particle. Because the particles are spherically symmetric, the 3D Fourier transform can be formulated as a 1D Fourier-Bessel integral:</p> \\[ F_\\alpha(Q) = 4\\pi \\int\\limits_{0}^{\\infty} \\Delta\\rho_\\alpha(r) \\, r^2 \\, \\dfrac{\\sin(Q \\, r)}{Q r} \\,\\mathrm{d} r. \\] <p>An important quantity is the size average of the squared amplitude</p> \\[ \\langle F^2(Q) \\rangle = \\sum_{\\alpha=1}^{n} x_\\alpha \\, F^2_\\alpha(Q). \\] <p>The size-averaged form factor can then be expressed as</p> \\[ P(Q) = \\dfrac{\\langle F^2(Q) \\rangle}{\\langle F^2(0) \\rangle}. \\] <p>The partial structure factors \\(S_{\\alpha \\beta}(Q)\\) describe the interparticle correlations between the particles of the species \\(\\alpha\\) and the species \\(\\beta\\). They form the matrix \\(\\mathbf{S}\\), which is related to the matrix of weighted direct correlation functions \\(\\mathbf{\\tilde{c}}\\) with elements \\(\\tilde{c}_{\\alpha\\beta} = \\sqrt{x_i x_j} \\, c_{\\alpha\\beta}\\) by the Ornstein-Zernike equation:</p> \\[ \\mathbf{S} = [\\mathbf{1} - \\rho \\mathbf{\\tilde{c}}]^{-1}, \\] <p>where \\(\\rho\\) is the total number density. The partial structure factors defined here follow the  property \\(S_{\\alpha\\beta}(Q\\to\\infty) = \\delta_{\\alpha\\beta}\\).</p>"},{"location":"background/#radius-of-gyration","title":"Radius of Gyration","text":"<p>The radius of gyration \\(R_\\mathrm{G}\\) describes the root mean square distance of the scattering  centers from the center of mass. For a single particle, it can be calculated from the radial contrast profile \\(\\Delta\\rho_\\alpha(r)\\) according to</p> \\[ R_{\\mathrm{G}, \\alpha}^2 = \\dfrac{4\\pi \\int\\limits_{0}^{\\infty} \\Delta\\rho_\\alpha(r) \\, r^4 \\,\\mathrm{d} r} {4\\pi \\int\\limits_{0}^{\\infty} \\Delta\\rho_\\alpha(r) \\, r^2 \\,\\mathrm{d} r} \\] <p>In a single component system, \\(R_\\mathrm{G}\\) is related to the initial slope of the form factor</p> \\[ P(Q) = 1 - \\dfrac{R_{\\mathrm{G}}^2}{3} Q^2 + \\mathcal O (Q^4), \\] <p>which leads to the well-known Guinier Law for small wavevectors</p> \\[ P(Q) \\approx \\exp{\\left(- \\frac{R_{\\mathrm{G}}^2}{3} Q^2 \\right)}. \\] <p>For particle mixtures, the Guinier approximation is still valid, however, with an averaged, apparent radius of gyration</p> \\[  \\langle R^2_\\mathrm G \\rangle = \\langle F^2(0) \\rangle^{-1} \\sum_{\\alpha=1}^{n} x_\\alpha \\, F^2_\\alpha(0)  R_{\\mathrm{G}, \\alpha}^2, \\] <p>such that</p> \\[ P(Q) \\approx \\exp{\\left(- \\frac{\\langle R_{\\mathrm{G}}^2 \\rangle }{3} Q^2 \\right)}. \\]"},{"location":"background/#effective-structure-factors","title":"Effective Structure Factors","text":"<p>There are multiple ways to define single effective, structure factors:</p> <ul> <li> <p>The measurable structure factor</p> \\[ S_{\\mathrm{M}}(Q) = \\langle F^2(Q) \\rangle^{-1} \\sum_{\\alpha, \\beta=1}^{n}     (x_\\alpha x_\\beta)^{1/2} \\, F_\\alpha(Q) \\, F_\\beta(Q) \\, S_{\\alpha \\beta}(Q), \\] <p>which is simply the intensity of a suspension divided by the intensity of a non-interacting suspension with the same scattering properties.</p> </li> <li> <p>The average number-number structure factor</p> \\[ S_{\\mathrm{NN}}(Q) = \\sum_{\\alpha, \\beta=1}^{n} (x_\\alpha x_\\beta)^{1/2} \\, S_{\\alpha \\beta}(Q), \\] <p>which is just the sum of all partial structure factors weighted with the size distribution. This effective structure factor describes the overall correlation between all existing particles.</p> </li> <li> <p>The \"compressibility\" structure factor</p> \\[ S_{\\mathrm{\\kappa}}(Q) = \\dfrac{1}{\\sum_{\\alpha, \\beta=1}^{n} x_\\alpha x_\\beta \\,   S_{\\alpha\\beta}^{-1}(Q)}, \\] <p>where \\(S_{\\alpha\\beta}^{-1}(Q)\\) denotes the \\(\\alpha\\beta\\) element of the inverse of the partial structure factor matrix. According to the Kirkwood-Buff theory of solutions, the isothermal compressibility \\(\\kappa_{\\mathrm{T}}\\) is related to the zero-\\(Q\\) limit of the partial structure factors by</p> \\[ \\rho k_\\mathrm B T \\kappa_{\\mathrm{T}} = \\dfrac{1}{\\sum_{\\alpha, \\beta=1}^{n} x_\\alpha x_\\beta \\,   S_{\\alpha\\beta}^{-1}(0)}. \\] <p>The compressibility structure factor extends this definition to finite \\(Q\\) and the relation</p> \\[ S_{\\mathrm{\\kappa}}(Q\\to0) =  \\rho k_\\mathrm B T \\kappa_{\\mathrm{T}} \\] <p>is satisfied.</p> </li> </ul>"},{"location":"background/#apparent-diffusion-coefficient","title":"Apparent Diffusion Coefficient","text":"<p>Of interest in the context of dynamic light scattering is the apparent Stokes-Einstein diffusion  coefficient, which for mixtures of particles depends on the scattering amplitudes and also  changes with the wavevector:</p> \\[ \\langle D_0(Q) \\rangle = \\langle F^2(Q) \\rangle^{-1} \\sum_{\\alpha=1}^{n} x_\\alpha \\, F^2_\\alpha(Q) D_{0, \\alpha}, \\] <p>with</p> \\[ D_{0, \\alpha} = \\dfrac{k_{\\mathrm{B}} T}{6 \\pi \\eta_0 R_{\\mathrm{h}, \\alpha}}, \\] <p>where \\(k_{\\mathrm{B}} T\\) indicates the thermal energy, \\(\\eta_0\\) the viscosity of the suspension medium and \\(R_{\\mathrm{h}, \\alpha}\\) the hydrodynamic radius of the  particles of species \\(\\alpha\\).</p> <p>An apparent hydrodynamic radius can then be defined as </p> \\[ R_{\\mathrm{h, app}}(Q) = \\dfrac{k_{\\mathrm{B}} T}{6 \\pi \\eta_0 \\langle D_0(Q) \\rangle}. \\]"},{"location":"api/core_api/","title":"mixscatter API","text":""},{"location":"api/core_api/#mixscatter.core","title":"<code>mixscatter.core</code>","text":"<p>This module provides convenience functions for calculating the scattered intensity, measurable structure factors and apparent diffusion coefficients for a given scattering model and liquid structure.</p> <p>Classes:</p> Name Description <code>LiquidStructureLike</code> <p>A protocol which defines an interface for a class which behaves like <code>LiquidStructure</code>.</p> <code>ScatteringModelLike</code> <p>A protocol which defines an interface for a class which behaves like <code>ScatteringModel</code>.</p> <code>MixtureLike</code> <p>A protocol which defines an interface for a class which behaves like <code>Mixture</code>.</p> <p>Functions:</p> Name Description <code>measurable_intensity</code> <p>Calculate the measured intensity for a given scattering model and liquid structure.</p> <code>measurable_structure_factor</code> <p>Calculate the measurable structure factor for a given scattering model and liquid structure.</p> <code>measurable_diffusion_coefficient</code> <p>Calculate the measured diffusion coefficient for a given scattering model and liquid</p>"},{"location":"api/core_api/#mixscatter.core.LiquidStructureLike","title":"<code>LiquidStructureLike</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol which defines an interface for a class which behaves like LiquidStructure.</p> <p>Any object which implements this protocol can be used by the functions in this module instead of a standard <code>LiquidStructure</code> object. This can be exploited to construct custom <code>LiquidStructureLike</code> objects with only the functionality strictly necessary.</p> Source code in <code>src/mixscatter/core.py</code> <pre><code>class LiquidStructureLike(Protocol):  # pragma: no cover\n    \"\"\"\n    A protocol which defines an interface for a class which behaves like LiquidStructure.\n\n    Any object which implements this protocol can be used by the functions in this module instead of a standard\n    `LiquidStructure` object. This can be exploited to construct custom `LiquidStructureLike` objects with\n    only the functionality strictly necessary.\n    \"\"\"\n\n    @property\n    def number_weighted_partial_structure_factor(self) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"api/core_api/#mixscatter.core.MixtureLike","title":"<code>MixtureLike</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol which defines an interface for a class which behaves like Mixture.</p> <p>Any object which implements this protocol can be used by the functions in this module instead of a standard <code>Mixture</code> object. This can be exploited to construct custom <code>MixtureLike</code> objects with only the functionality strictly necessary.</p> Source code in <code>src/mixscatter/core.py</code> <pre><code>class MixtureLike(Protocol):  # pragma: no cover\n    \"\"\"\n    A protocol which defines an interface for a class which behaves like Mixture.\n\n    Any object which implements this protocol can be used by the functions in this module instead of a standard\n    `Mixture` object. This can be exploited to construct custom `MixtureLike` objects with\n    only the functionality strictly necessary.\n    \"\"\"\n\n    @property\n    def radius(self) -&gt; NDArray[np.float64]: ...\n\n    @property\n    def number_fraction(self) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"api/core_api/#mixscatter.core.ScatteringModelLike","title":"<code>ScatteringModelLike</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol which defines an interface for a class which behaves like ScatteringModel.</p> <p>Any object which implements this protocol can be used by the functions in this module instead of a standard <code>ScatteringModel</code> object. This can be exploited to construct custom <code>ScatteringModelLike</code> objects with only the functionality strictly necessary.</p> Source code in <code>src/mixscatter/core.py</code> <pre><code>class ScatteringModelLike(Protocol):  # pragma: no cover\n    \"\"\"\n    A protocol which defines an interface for a class which behaves like ScatteringModel.\n\n    Any object which implements this protocol can be used by the functions in this module instead of a standard\n    `ScatteringModel` object. This can be exploited to construct custom `ScatteringModelLike` objects with\n    only the functionality strictly necessary.\n    \"\"\"\n\n    mixture: MixtureLike\n\n    @property\n    def amplitude(self) -&gt; NDArray[np.float64]: ...\n\n    @property\n    def average_square_amplitude(self) -&gt; NDArray[np.float64]: ...\n\n    @property\n    def average_square_forward_amplitude(self) -&gt; float: ...\n\n    @property\n    def average_form_factor(self) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"api/core_api/#mixscatter.core.measurable_diffusion_coefficient","title":"<code>measurable_diffusion_coefficient(scattering_model, thermal_energy, viscosity)</code>","text":"<p>Calculate the measurable Stokes-Einstein diffusion coefficient of a dilute suspension.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_model</code> <code>ScatteringModelLike</code> <p><code>ScatteringModel</code> instance or an object with an interface similar to <code>ScatteringModel</code>.</p> required <code>thermal_energy</code> <code>float</code> <p>Thermal energy.</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of the surrounding medium.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Measurable diffusion coefficient.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture, SimpleSphere, measurable_diffusion_coefficient\n</code></pre> <pre><code>&gt;&gt;&gt; wavevector = np.linspace(0.005, 0.05, 100)\n&gt;&gt;&gt; mixture = Mixture([100, 200], [0.2, 0.8])\n&gt;&gt;&gt; scattering_model = SimpleSphere(wavevector, mixture, contrast=1.0)\n</code></pre> <pre><code>&gt;&gt;&gt; D_0 = measurable_diffusion_coefficient(\n...     scattering_model, thermal_energy=1.0, viscosity=1.0\n... )\n</code></pre> Source code in <code>src/mixscatter/core.py</code> <pre><code>def measurable_diffusion_coefficient(\n    scattering_model: ScatteringModelLike, thermal_energy: float, viscosity: float\n) -&gt; NDArray[np.float64]:\n    # noinspection PyShadowingNames\n    \"\"\"\n    Calculate the measurable Stokes-Einstein diffusion coefficient of a dilute suspension.\n\n    Args:\n        scattering_model:\n            `ScatteringModel` instance or an object with an interface similar to `ScatteringModel`.\n        thermal_energy:\n            Thermal energy.\n        viscosity:\n            Viscosity of the surrounding medium.\n\n    Returns:\n        Measurable diffusion coefficient.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from mixscatter import Mixture, SimpleSphere, measurable_diffusion_coefficient\n\n        &gt;&gt;&gt; wavevector = np.linspace(0.005, 0.05, 100)\n        &gt;&gt;&gt; mixture = Mixture([100, 200], [0.2, 0.8])\n        &gt;&gt;&gt; scattering_model = SimpleSphere(wavevector, mixture, contrast=1.0)\n\n        &gt;&gt;&gt; D_0 = measurable_diffusion_coefficient(\n        ...     scattering_model, thermal_energy=1.0, viscosity=1.0\n        ... )\n    \"\"\"\n    weighted_inverse_radius: NDArray[np.float64] = np.asanyarray(\n        np.sum(\n            scattering_model.mixture.number_fraction[:, np.newaxis]\n            * scattering_model.amplitude**2\n            / scattering_model.mixture.radius[:, np.newaxis],\n            axis=0,\n        ),\n        dtype=np.float64,\n    )\n    weighted_inverse_radius /= scattering_model.average_square_amplitude\n    prefactor = thermal_energy / (6.0 * np.pi * viscosity)\n    return prefactor * weighted_inverse_radius\n</code></pre>"},{"location":"api/core_api/#mixscatter.core.measurable_intensity","title":"<code>measurable_intensity(liquid_structure, scattering_model, scale=1.0, background=0.0)</code>","text":"<p>Calculate the measured intensity for a given scattering model and liquid structure.</p> <p>Parameters:</p> Name Type Description Default <code>liquid_structure</code> <code>LiquidStructureLike</code> <p><code>LiquidStructure</code> instance or an object with an interface similar to <code>LiquidStructure</code>.</p> required <code>scattering_model</code> <code>ScatteringModelLike</code> <p><code>ScatteringModel</code> instance or an object with an interface similar to <code>ScatteringModel</code>.</p> required <code>scale</code> <code>float</code> <p>Scale the intensity by a factor.</p> <code>1.0</code> <code>background</code> <code>float</code> <p>Add a constant background.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Measurable scattered intensity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture, PercusYevick, SimpleSphere, measurable_intensity\n</code></pre> <pre><code>&gt;&gt;&gt; wavevector = np.linspace(0.005, 0.05, 100)\n&gt;&gt;&gt; mixture = Mixture([100, 200], [0.2, 0.8])\n</code></pre> <pre><code>&gt;&gt;&gt; liquid_structure = PercusYevick(wavevector, mixture, volume_fraction_total=0.3)\n&gt;&gt;&gt; scattering_model = SimpleSphere(wavevector, mixture, contrast=1.0)\n</code></pre> <pre><code>&gt;&gt;&gt; intensity = measurable_intensity(\n...     liquid_structure, scattering_model, scale=1e5, background=1e3\n... )\n</code></pre> Source code in <code>src/mixscatter/core.py</code> <pre><code>def measurable_intensity(\n    liquid_structure: LiquidStructureLike,\n    scattering_model: ScatteringModelLike,\n    scale: float = 1.0,\n    background: float = 0.0,\n) -&gt; NDArray[np.float64]:\n    # noinspection PyShadowingNames\n    \"\"\"\n    Calculate the measured intensity for a given scattering model and liquid structure.\n\n    Args:\n        liquid_structure:\n            `LiquidStructure` instance or an object with an interface similar to `LiquidStructure`.\n        scattering_model:\n            `ScatteringModel` instance or an object with an interface similar to `ScatteringModel`.\n        scale:\n            Scale the intensity by a factor.\n        background:\n            Add a constant background.\n\n    Returns:\n        Measurable scattered intensity.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from mixscatter import Mixture, PercusYevick, SimpleSphere, measurable_intensity\n\n        &gt;&gt;&gt; wavevector = np.linspace(0.005, 0.05, 100)\n        &gt;&gt;&gt; mixture = Mixture([100, 200], [0.2, 0.8])\n\n        &gt;&gt;&gt; liquid_structure = PercusYevick(wavevector, mixture, volume_fraction_total=0.3)\n        &gt;&gt;&gt; scattering_model = SimpleSphere(wavevector, mixture, contrast=1.0)\n\n        &gt;&gt;&gt; intensity = measurable_intensity(\n        ...     liquid_structure, scattering_model, scale=1e5, background=1e3\n        ... )\n    \"\"\"\n    average_intensity: NDArray[np.float64] = np.einsum(\n        \"iq, jq, ijq-&gt;q\",\n        scattering_model.amplitude,\n        scattering_model.amplitude,\n        liquid_structure.number_weighted_partial_structure_factor,\n    )\n    normalized_intensity = scale * average_intensity / scattering_model.average_square_forward_amplitude + background\n    return normalized_intensity\n</code></pre>"},{"location":"api/core_api/#mixscatter.core.measurable_structure_factor","title":"<code>measurable_structure_factor(liquid_structure, scattering_model)</code>","text":"<p>Calculate the measurable structure factor for a given scattering model and liquid structure.</p> <p>This is the quotient of the measurable intensity of a system with interactions and the equivalent intensity of a system without interactions.</p> <p>Parameters:</p> Name Type Description Default <code>liquid_structure</code> <code>LiquidStructureLike</code> <p><code>LiquidStructure</code> instance or an object with an interface similar to <code>LiquidStructure</code>.</p> required <code>scattering_model</code> <code>ScatteringModelLike</code> <p><code>ScatteringModel</code> instance or an object with an interface similar to <code>ScatteringModel</code>.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Measurable structure factor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture, PercusYevick, SimpleSphere, measurable_structure_factor\n</code></pre> <pre><code>&gt;&gt;&gt; wavevector = np.linspace(0.005, 0.05, 100)\n&gt;&gt;&gt; mixture = Mixture([100, 200], [0.2, 0.8])\n</code></pre> <pre><code>&gt;&gt;&gt; liquid_structure = PercusYevick(wavevector, mixture, volume_fraction_total=0.3)\n&gt;&gt;&gt; scattering_model = SimpleSphere(wavevector, mixture, contrast=1.0)\n</code></pre> <pre><code>&gt;&gt;&gt; structure_factor = measurable_structure_factor(liquid_structure, scattering_model)\n</code></pre> Source code in <code>src/mixscatter/core.py</code> <pre><code>def measurable_structure_factor(\n    liquid_structure: LiquidStructureLike, scattering_model: ScatteringModelLike\n) -&gt; NDArray[np.float64]:\n    # noinspection PyShadowingNames\n    \"\"\"\n    Calculate the measurable structure factor for a given scattering model and liquid structure.\n\n    This is the quotient of the measurable intensity of a system with interactions and the\n    equivalent intensity of a system without interactions.\n\n    Args:\n        liquid_structure:\n            `LiquidStructure` instance or an object with an interface similar to `LiquidStructure`.\n        scattering_model:\n            `ScatteringModel` instance or an object with an interface similar to `ScatteringModel`.\n\n    Returns:\n        Measurable structure factor.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from mixscatter import Mixture, PercusYevick, SimpleSphere, measurable_structure_factor\n\n        &gt;&gt;&gt; wavevector = np.linspace(0.005, 0.05, 100)\n        &gt;&gt;&gt; mixture = Mixture([100, 200], [0.2, 0.8])\n\n        &gt;&gt;&gt; liquid_structure = PercusYevick(wavevector, mixture, volume_fraction_total=0.3)\n        &gt;&gt;&gt; scattering_model = SimpleSphere(wavevector, mixture, contrast=1.0)\n\n        &gt;&gt;&gt; structure_factor = measurable_structure_factor(liquid_structure, scattering_model)\n    \"\"\"\n    return measurable_intensity(liquid_structure, scattering_model) / scattering_model.average_form_factor\n</code></pre>"},{"location":"api/liquidstructure_api/","title":"liquidstructure API","text":""},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure","title":"<code>mixscatter.liquidstructure</code>","text":"<p>This module provides classes for representing the liquid structure properties of interacting multicomponent systems of spherical particles.</p> <p>Classes:</p> Name Description <code>LiquidStructure</code> <p>Abstract base class representing liquid structure properties.</p> <code>PercusYevick</code> <p>Class for hard-sphere potential in the Percus-Yevick approximation.</p> <code>VerletWeis</code> <p>Class for hard-sphere potential in the Percus-Yevick approximation with Verlet-Weiss correction.</p> References <ul> <li>P. Salgi, R. Rajagopalan, \"Polydispersity in colloids: implications to static structure and scattering\",   Adv. Colloid Interface Sci. 43, 169-288 (1993), https://doi.org/10.1016/0001-8686(93)80017-6</li> <li>A. Vrij, \"Mixtures of hard spheres in the Percus\u2013Yevick approximation. Light scattering at finite angles\",   J. Chem. Phys. 71, 3267-3270 (1979), https://doi.org/10.1063/1.438756</li> <li>J. Diaz Maier, K. Gaus, J. Wagner, \"Measurable structure factors of dense dispersions containing polydisperse,   optically inhomogeneous particles\", arXiv:2404.03470 [cond-mat.soft], https://doi.org/10.48550/arXiv.2404.03470</li> </ul>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure","title":"<code>LiquidStructure</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Representation of the liquid structure properties of an interacting multicomponent system of spherical particles.</p> <p>Specialized classes inherit from this base class and only need to implement the 'partial_direct_correlation_function' attribute.</p> <p>Attributes:</p> Name Type Description <code>wavevector</code> <code>NDArray[float64]</code> <p>Scattering wavevector.</p> <code>mixture</code> <code>MixtureLike</code> <p>Mixture object.</p> References <ul> <li>P. Salgi, R. Rajagopalan, \"Polydispersity in colloids: implications to static structure and scattering\",   Adv. Colloid Interface Sci. 43, 169-288 (1993), https://doi.org/10.1016/0001-8686(93)80017-6</li> <li>A. Vrij, \"Mixtures of hard spheres in the Percus\u2013Yevick approximation. Light scattering at finite angles\",   J. Chem. Phys. 71, 3267-3270 (1979), https://doi.org/10.1063/1.438756</li> <li>J. Diaz Maier, K. Gaus, J. Wagner, \"Measurable structure factors of dense dispersions containing polydisperse,   optically inhomogeneous particles\", arXiv:2404.03470 [cond-mat.soft],   https://doi.org/10.48550/arXiv.2404.03470</li> </ul> Source code in <code>src/mixscatter/liquidstructure/liquidstructure.py</code> <pre><code>class LiquidStructure(ABC):\n    \"\"\"\n    Representation of the liquid structure properties of an interacting multicomponent system of\n    spherical particles.\n\n    Specialized classes inherit from this base class and only need to implement the\n    'partial_direct_correlation_function' attribute.\n\n    Attributes:\n        wavevector (NDArray[np.float64]): Scattering wavevector.\n        mixture (MixtureLike): Mixture object.\n\n    References:\n        - P. Salgi, R. Rajagopalan, \"Polydispersity in colloids: implications to static structure and scattering\",\n          Adv. Colloid Interface Sci. 43, 169-288 (1993), https://doi.org/10.1016/0001-8686(93)80017-6\n        - A. Vrij, \"Mixtures of hard spheres in the Percus\u2013Yevick approximation. Light scattering at finite angles\",\n          J. Chem. Phys. 71, 3267-3270 (1979), https://doi.org/10.1063/1.438756\n        - J. Diaz Maier, K. Gaus, J. Wagner, \"Measurable structure factors of dense dispersions containing polydisperse,\n          optically inhomogeneous particles\", arXiv:2404.03470 [cond-mat.soft],\n          https://doi.org/10.48550/arXiv.2404.03470\n    \"\"\"\n\n    def __init__(self, wavevector: ArrayLike, mixture: MixtureLike):\n        \"\"\"\n        Initialize an instance based on the specified wavevectors and for a given mixture.\n\n        Args:\n            wavevector (ArrayLike): Scattering wavevector.\n            mixture (MixtureLike): Mixture object.\n        \"\"\"\n        self.wavevector: NDArray[np.float64] = np.asarray(wavevector, dtype=np.float64)\n        self.mixture: MixtureLike = mixture\n\n    @abstractmethod\n    @cached_property\n    def partial_direct_correlation_function(self) -&gt; NDArray[np.float64]:  # pragma: no cover\n        \"\"\"\n        Matrix of the partial direct correlation functions weighted by the total number density.\n\n        Returns:\n            NDArray[np.float64]: Partial direct correlation function matrix.\n        \"\"\"\n        ...\n\n    @cached_property\n    def number_weighted_partial_direct_correlation_function(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The partial direct correlation function matrix `c_ij` weighted by the square root of the\n        product of the number fractions `x_i` and `x_j`.\n\n        Returns:\n            NDArray[np.float64]: Matrix of the weighted direct partial correlation functions.\n        \"\"\"\n        c_weighted_ijq: NDArray[np.float64] = np.einsum(\n            \"i, ijq, j-&gt;ijq\",\n            np.sqrt(self.mixture.number_fraction),\n            self.partial_direct_correlation_function,\n            np.sqrt(self.mixture.number_fraction),\n            optimize=\"greedy\",\n        )\n        return c_weighted_ijq\n\n    @cached_property\n    def partial_structure_factor(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The partial structure factor matrix.\n\n        Returns:\n            NDArray[np.float64]: Matrix of the partial structure factors.\n        \"\"\"\n        c_weighted_ijq = self.number_weighted_partial_direct_correlation_function\n        c_weighted_qij = np.moveaxis(c_weighted_ijq, -1, 0)\n        unity_tensor_qij = np.eye(self.mixture.number_of_components)[np.newaxis, :, :]\n        S_inv_qij = unity_tensor_qij - c_weighted_qij\n        S_qij = np.linalg.solve(S_inv_qij, unity_tensor_qij)\n        S_ijq = np.asanyarray(np.moveaxis(S_qij, 0, -1), dtype=np.float64)\n        return S_ijq\n\n    @cached_property\n    def number_weighted_partial_structure_factor(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The partial direct correlation function matrix `S_ij` weighted by the square root of the\n        product of the number fractions `x_i` and `x_j`.\n\n        Returns:\n            NDArray[np.float64]: Matrix of the weighted direct partial correlation functions.\n        \"\"\"\n        S_weighted_ijq: NDArray[np.float64] = np.einsum(\n            \"i, ijq, j-&gt;ijq\",\n            np.sqrt(self.mixture.number_fraction),\n            self.partial_structure_factor,\n            np.sqrt(self.mixture.number_fraction),\n            optimize=\"greedy\",\n        )\n        return S_weighted_ijq\n\n    @cached_property\n    def average_structure_factor(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The sum of the number weighted partial structure factors over all species.\n\n        The number-number structure factor for all species, regardless their individual size.\n\n        Returns:\n            NDArray[np.float64]: Average structure factor.\n        \"\"\"\n        average_structure_factor: NDArray[np.float64] = np.einsum(\n            \"ijq-&gt;q\", self.number_weighted_partial_structure_factor\n        )\n        return average_structure_factor\n\n    @cached_property\n    def compressibility_structure_factor(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The \"compressibility\" or \"Kirkwood-Buff\" structure factor.\n\n        This structure factor gives the correct isothermal compressibility from S(Q-&gt;0) according\n        to the Kirkwood-Buff-theory for multicomponent systems.\n\n        Returns:\n            NDArray[np.float64]: \"Compressibility\" structure factor.\n        \"\"\"\n        S_weighted_ijq = self.number_weighted_partial_structure_factor\n        S_weighted_qij = np.moveaxis(S_weighted_ijq, -1, 0)\n        S_weighted_inverse_qij = np.linalg.inv(S_weighted_qij)\n        compressibility_structure_factor: NDArray[np.float64] = 1.0 / np.einsum(\n            \"i, j, qij-&gt;q\",\n            self.mixture.number_fraction,\n            self.mixture.number_fraction,\n            S_weighted_inverse_qij,\n        )\n        return compressibility_structure_factor\n</code></pre>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.average_structure_factor","title":"<code>average_structure_factor</code>  <code>cached</code> <code>property</code>","text":"<p>The sum of the number weighted partial structure factors over all species.</p> <p>The number-number structure factor for all species, regardless their individual size.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Average structure factor.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.compressibility_structure_factor","title":"<code>compressibility_structure_factor</code>  <code>cached</code> <code>property</code>","text":"<p>The \"compressibility\" or \"Kirkwood-Buff\" structure factor.</p> <p>This structure factor gives the correct isothermal compressibility from S(Q-&gt;0) according to the Kirkwood-Buff-theory for multicomponent systems.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: \"Compressibility\" structure factor.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.number_weighted_partial_direct_correlation_function","title":"<code>number_weighted_partial_direct_correlation_function</code>  <code>cached</code> <code>property</code>","text":"<p>The partial direct correlation function matrix <code>c_ij</code> weighted by the square root of the product of the number fractions <code>x_i</code> and <code>x_j</code>.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Matrix of the weighted direct partial correlation functions.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.number_weighted_partial_structure_factor","title":"<code>number_weighted_partial_structure_factor</code>  <code>cached</code> <code>property</code>","text":"<p>The partial direct correlation function matrix <code>S_ij</code> weighted by the square root of the product of the number fractions <code>x_i</code> and <code>x_j</code>.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Matrix of the weighted direct partial correlation functions.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.partial_direct_correlation_function","title":"<code>partial_direct_correlation_function</code>  <code>abstractmethod</code> <code>cached</code> <code>property</code>","text":"<p>Matrix of the partial direct correlation functions weighted by the total number density.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Partial direct correlation function matrix.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.partial_structure_factor","title":"<code>partial_structure_factor</code>  <code>cached</code> <code>property</code>","text":"<p>The partial structure factor matrix.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Matrix of the partial structure factors.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.LiquidStructure.__init__","title":"<code>__init__(wavevector, mixture)</code>","text":"<p>Initialize an instance based on the specified wavevectors and for a given mixture.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <code>mixture</code> <code>MixtureLike</code> <p>Mixture object.</p> required Source code in <code>src/mixscatter/liquidstructure/liquidstructure.py</code> <pre><code>def __init__(self, wavevector: ArrayLike, mixture: MixtureLike):\n    \"\"\"\n    Initialize an instance based on the specified wavevectors and for a given mixture.\n\n    Args:\n        wavevector (ArrayLike): Scattering wavevector.\n        mixture (MixtureLike): Mixture object.\n    \"\"\"\n    self.wavevector: NDArray[np.float64] = np.asarray(wavevector, dtype=np.float64)\n    self.mixture: MixtureLike = mixture\n</code></pre>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.PercusYevick","title":"<code>PercusYevick</code>","text":"<p>               Bases: <code>LiquidStructure</code></p> <p>Hard-sphere potential in the Percus-Yevick approximation.</p> References <ul> <li>A. Vrij, \"Mixtures of hard spheres in the Percus\u2013Yevick approximation. Light scattering at finite angles\",   J. Chem. Phys. 71, 3267-3270 (1979), https://doi.org/10.1063/1.438756</li> <li>T. Voigtmann, \"Mode Coupling Theory of the Glass Transition in Binary Mixtures\",   PhD Thesis, TU M\u00fcnchen, https://mediatum.ub.tum.de/603008</li> <li>J. Diaz Maier, K. Gaus, J. Wagner, \"Measurable structure factors of dense dispersions containing polydisperse,   optically inhomogeneous particles\", arXiv:2404.03470 [cond-mat.soft],   https://doi.org/10.48550/arXiv.2404.03470</li> </ul> Source code in <code>src/mixscatter/liquidstructure/liquidstructure.py</code> <pre><code>class PercusYevick(LiquidStructure):\n    \"\"\"\n    Hard-sphere potential in the Percus-Yevick approximation.\n\n    References:\n        - A. Vrij, \"Mixtures of hard spheres in the Percus\u2013Yevick approximation. Light scattering at finite angles\",\n          J. Chem. Phys. 71, 3267-3270 (1979), https://doi.org/10.1063/1.438756\n        - T. Voigtmann, \"Mode Coupling Theory of the Glass Transition in Binary Mixtures\",\n          PhD Thesis, TU M\u00fcnchen, https://mediatum.ub.tum.de/603008\n        - J. Diaz Maier, K. Gaus, J. Wagner, \"Measurable structure factors of dense dispersions containing polydisperse,\n          optically inhomogeneous particles\", arXiv:2404.03470 [cond-mat.soft],\n          https://doi.org/10.48550/arXiv.2404.03470\n    \"\"\"\n\n    def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, volume_fraction_total: float):\n        \"\"\"\n        Initialize an instance based on the specified wavevectors and for a given mixture.\n\n        Args:\n            wavevector (ArrayLike): Scattering wavevector.\n            mixture (MixtureLike): Mixture object.\n            volume_fraction_total (float): Total volume fraction.\n        \"\"\"\n        self.volume_fraction_total: float = volume_fraction_total\n        super().__init__(wavevector, mixture)\n\n    @cached_property\n    def partial_direct_correlation_function(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Calculate the partial direct correlation function matrix `c_ij(q)` for the system using the\n        Percus-Yevick approximation.\n\n        Returns:\n            NDArray[np.float64]: Partial direct correlation function matrix `c_ij(q)` times the total number density.\n        \"\"\"\n        average_volume = 4.0 / 3.0 * np.pi * self.mixture.moment(3)\n        number_density_total = self.volume_fraction_total / average_volume\n        number_density = number_density_total * self.mixture.number_fraction\n\n        diameter = 2.0 * self.mixture.radius\n        xi = [np.pi / 6.0 * np.sum(number_density * diameter**x) for x in range(1, 4)]\n        diameter_mean = 0.5 * (diameter[:, np.newaxis] + diameter)\n        diameter_product = diameter[:, np.newaxis] * diameter\n        beta_hat_0 = (9.0 * xi[1] ** 2 + 3.0 * xi[0] * (1 - xi[2])) / (1 - xi[2]) ** 3\n        a_i = (1.0 - xi[2] + 3.0 * diameter * xi[1]) / (1 - xi[2]) ** 2\n        a_tilde_2 = np.sum(number_density * a_i**2)\n        A_ij = (diameter_mean * (1 - xi[2]) + 1.5 * diameter_product * xi[1]) / (1 - xi[2]) ** 2\n        B_ij = 1.0 / (1 - 0 - xi[2]) - beta_hat_0 * diameter_product\n        D_ij = (6.0 * xi[1] + 12.0 * diameter_mean * (xi[0] + 3.0 * xi[1] ** 2 / (1 - xi[2]))) / (1 - xi[2]) ** 2\n        wavevector_reduced = self.mixture.radius[:, np.newaxis] * self.wavevector\n        wavevector_reciprocal = 1.0 / self.wavevector\n        sin_iq = np.sin(wavevector_reduced)\n        cos_iq = np.cos(wavevector_reduced)\n\n        c_ijq = 4.0 * np.pi * a_tilde_2 * sin_iq[:, np.newaxis] * sin_iq\n        c_ijq *= wavevector_reciprocal\n\n        c_ijq -= (\n            2.0\n            * np.pi\n            * a_tilde_2\n            * (\n                cos_iq[:, np.newaxis] * sin_iq * diameter[:, np.newaxis, np.newaxis]\n                + sin_iq[:, np.newaxis] * cos_iq * diameter[np.newaxis, :, np.newaxis]\n            )\n        )\n        c_ijq *= wavevector_reciprocal\n\n        c_ijq += (\n            D_ij[:, :, np.newaxis] * sin_iq[:, np.newaxis] * sin_iq\n            + np.pi * a_tilde_2 * cos_iq[:, np.newaxis] * cos_iq * diameter_product[:, :, np.newaxis]\n        )\n        c_ijq *= wavevector_reciprocal\n\n        c_ijq += B_ij[:, :, np.newaxis] * (cos_iq[:, np.newaxis] * sin_iq + sin_iq[:, np.newaxis] * cos_iq)\n        c_ijq *= wavevector_reciprocal\n\n        c_ijq += A_ij[:, :, np.newaxis] * (sin_iq[:, np.newaxis] * sin_iq - cos_iq[:, np.newaxis] * cos_iq)\n        c_ijq *= -4.0 * np.pi * wavevector_reciprocal**2\n        c_ijq *= number_density_total\n        return np.asarray(c_ijq, dtype=np.float64)\n</code></pre>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.PercusYevick.partial_direct_correlation_function","title":"<code>partial_direct_correlation_function</code>  <code>cached</code> <code>property</code>","text":"<p>Calculate the partial direct correlation function matrix <code>c_ij(q)</code> for the system using the Percus-Yevick approximation.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Partial direct correlation function matrix <code>c_ij(q)</code> times the total number density.</p>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.PercusYevick.__init__","title":"<code>__init__(wavevector, mixture, volume_fraction_total)</code>","text":"<p>Initialize an instance based on the specified wavevectors and for a given mixture.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <code>mixture</code> <code>MixtureLike</code> <p>Mixture object.</p> required <code>volume_fraction_total</code> <code>float</code> <p>Total volume fraction.</p> required Source code in <code>src/mixscatter/liquidstructure/liquidstructure.py</code> <pre><code>def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, volume_fraction_total: float):\n    \"\"\"\n    Initialize an instance based on the specified wavevectors and for a given mixture.\n\n    Args:\n        wavevector (ArrayLike): Scattering wavevector.\n        mixture (MixtureLike): Mixture object.\n        volume_fraction_total (float): Total volume fraction.\n    \"\"\"\n    self.volume_fraction_total: float = volume_fraction_total\n    super().__init__(wavevector, mixture)\n</code></pre>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.VerletWeis","title":"<code>VerletWeis</code>","text":"<p>               Bases: <code>PercusYevick</code></p> <p>Hard-sphere potential in the Percus-Yevick approximation employing the Verlet-Weis correction.</p> <p>Uses the PercusYevick class with an effective volume fraction and an effective radius.</p> References <ul> <li>E. W. Grundke and D. Henderson, \"Distribution functions of multi-component fluid mixtures of hard spheres\",   Mol. Phys. 24, 269-281 (1972), https://doi.org/10.1080/00268977200101431</li> </ul> Source code in <code>src/mixscatter/liquidstructure/liquidstructure.py</code> <pre><code>class VerletWeis(PercusYevick):\n    \"\"\"\n    Hard-sphere potential in the Percus-Yevick approximation employing the Verlet-Weis correction.\n\n    Uses the PercusYevick class with an effective volume fraction and an effective radius.\n\n    References:\n        - E. W. Grundke and D. Henderson, \"Distribution functions of multi-component fluid mixtures of hard spheres\",\n          Mol. Phys. 24, 269-281 (1972), https://doi.org/10.1080/00268977200101431\n    \"\"\"\n\n    def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, volume_fraction_total: float) -&gt; None:\n        \"\"\"\n        Initialize an instance based on the specified wavevectors and for a given mixture.\n\n        Args:\n            wavevector (ArrayLike): Scattering wavevector.\n            mixture (MixtureLike): Mixture object.\n            volume_fraction_total (float): Total volume_fraction.\n        \"\"\"\n        effective_volume_fraction = volume_fraction_total * (1.0 - volume_fraction_total / 16.0)\n        effective_radius = mixture.radius * (effective_volume_fraction / volume_fraction_total) ** (1.0 / 3.0)\n        effective_mixture = deepcopy(mixture)\n        # Some static type checkers at the moment cannot handle protocols implementing property setters\n        # and since a mutable radius property is only needed here, a manual isinstance assertion is performed\n        if (\n            isinstance(effective_mixture, HasMutableRadius)\n            and getattr(type(effective_mixture), \"radius\").fset is not None\n        ):\n            effective_mixture.radius = effective_radius\n            assert isinstance(effective_mixture, MixtureLike)\n        else:\n            raise AttributeError(\"`radius` property of `mixture` must be mutable.\")\n\n        super().__init__(wavevector, effective_mixture, volume_fraction_total=effective_volume_fraction)\n</code></pre>"},{"location":"api/liquidstructure_api/#mixscatter.liquidstructure.VerletWeis.__init__","title":"<code>__init__(wavevector, mixture, volume_fraction_total)</code>","text":"<p>Initialize an instance based on the specified wavevectors and for a given mixture.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <code>mixture</code> <code>MixtureLike</code> <p>Mixture object.</p> required <code>volume_fraction_total</code> <code>float</code> <p>Total volume_fraction.</p> required Source code in <code>src/mixscatter/liquidstructure/liquidstructure.py</code> <pre><code>def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, volume_fraction_total: float) -&gt; None:\n    \"\"\"\n    Initialize an instance based on the specified wavevectors and for a given mixture.\n\n    Args:\n        wavevector (ArrayLike): Scattering wavevector.\n        mixture (MixtureLike): Mixture object.\n        volume_fraction_total (float): Total volume_fraction.\n    \"\"\"\n    effective_volume_fraction = volume_fraction_total * (1.0 - volume_fraction_total / 16.0)\n    effective_radius = mixture.radius * (effective_volume_fraction / volume_fraction_total) ** (1.0 / 3.0)\n    effective_mixture = deepcopy(mixture)\n    # Some static type checkers at the moment cannot handle protocols implementing property setters\n    # and since a mutable radius property is only needed here, a manual isinstance assertion is performed\n    if (\n        isinstance(effective_mixture, HasMutableRadius)\n        and getattr(type(effective_mixture), \"radius\").fset is not None\n    ):\n        effective_mixture.radius = effective_radius\n        assert isinstance(effective_mixture, MixtureLike)\n    else:\n        raise AttributeError(\"`radius` property of `mixture` must be mutable.\")\n\n    super().__init__(wavevector, effective_mixture, volume_fraction_total=effective_volume_fraction)\n</code></pre>"},{"location":"api/mixture_api/","title":"mixture API","text":""},{"location":"api/mixture_api/#mixscatter.mixture","title":"<code>mixscatter.mixture</code>","text":"<p>This module provides functionalities to represent and create mixtures of spherical particles with various size distributions. It includes classes and functions to handle different distributions like single-component, Flory-Schulz, Gaussian, and uniform distributions.</p> <p>Classes:</p> Name Description <code>Mixture</code> <p>Base class representing an N-component mixture of spherical particles.</p> <code>FlorySchulzMixture</code> <p>Represents a Schulz-Flory distributed mixture.</p> <code>GaussianMixture</code> <p>Represents a Gaussian distributed mixture.</p> <code>UniformMixture</code> <p>Represents a uniformly distributed mixture.</p> <code>SingleComponent</code> <p>Represents a pseudo one-component system.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.FlorySchulzMixture","title":"<code>FlorySchulzMixture</code>","text":"<p>               Bases: <code>Mixture</code></p> <p>Representation of a Schulz-Flory distributed mixture.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_components</code> <code>int</code> <p>Number of components in the mixture.</p> required <code>mean_radius</code> <code>float</code> <p>Mean radius of the distribution.</p> required <code>shape_parameter</code> <code>float</code> <p>Flory parameter controlling the distribution shape.</p> required Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>class FlorySchulzMixture(Mixture):\n    \"\"\"Representation of a Schulz-Flory distributed mixture.\n\n    Args:\n        number_of_components: Number of components in the mixture.\n        mean_radius: Mean radius of the distribution.\n        shape_parameter: Flory parameter controlling the distribution shape.\n    \"\"\"\n\n    def __init__(self, number_of_components: int, mean_radius: float, shape_parameter: float) -&gt; None:\n        roots, weights = self._flory_schulz_weights(\n            int(number_of_components), float(mean_radius), float(shape_parameter)\n        )\n        super().__init__(roots, weights)\n\n    @classmethod\n    def _flory_schulz_weights(\n        cls, number_of_components: int, mean_radius: float, shape_parameter: float\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        roots, weights = cls._generalized_laguerre_weights(number_of_components, shape_parameter)\n        scaled_roots = np.asanyarray(roots * mean_radius / (shape_parameter + 1.0), dtype=np.float64)\n        weights /= np.sum(weights)\n        return scaled_roots, weights\n\n    @staticmethod\n    def _generalized_laguerre_weights(order: int, exponent: float) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        roots, *_ = roots_genlaguerre(order, exponent)\n        roots = np.asanyarray(roots, dtype=np.float64)\n        values_at_roots = eval_genlaguerre(order + 1, exponent, roots)\n        abs_values_at_roots = np.abs(values_at_roots)\n        log_weights = np.log(roots) - 2.0 * np.log(abs_values_at_roots)\n        weights = np.exp(log_weights)\n        return roots, weights\n</code></pre>"},{"location":"api/mixture_api/#mixscatter.mixture.GaussianMixture","title":"<code>GaussianMixture</code>","text":"<p>               Bases: <code>Mixture</code></p> <p>Representation of a Gaussian distributed mixture.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_components</code> <code>int</code> <p>Number of components in the mixture.</p> required <code>mean_radius</code> <code>float</code> <p>Mean radius of the distribution.</p> required <code>standard_deviation</code> <code>float</code> <p>Standard deviation of the distribution.</p> required <code>truncate</code> <code>str</code> <p>Method to handle unphysical radii. Options are 'no', 'negatives', and 'symmetric'.</p> <ul> <li> <p>'no': No truncation</p> </li> <li> <p>'negatives': Truncate negative radii.</p> </li> <li> <p>'symmetric': Truncate negative radii and force the distribution to stay symmetric.</p> </li> </ul> <code>'negatives'</code> Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>class GaussianMixture(Mixture):\n    \"\"\"Representation of a Gaussian distributed mixture.\n\n    Args:\n        number_of_components: Number of components in the mixture.\n        mean_radius: Mean radius of the distribution.\n        standard_deviation: Standard deviation of the distribution.\n        truncate:\n            Method to handle unphysical radii. Options are 'no', 'negatives', and 'symmetric'.\n\n            - 'no': No truncation\n\n            - 'negatives': Truncate negative radii.\n\n            - 'symmetric': Truncate negative radii and force the distribution to stay symmetric.\n    \"\"\"\n\n    def __init__(\n        self, number_of_components: int, mean_radius: float, standard_deviation: float, truncate: str = \"negatives\"\n    ) -&gt; None:\n        if truncate not in [\"no\", \"negatives\", \"symmetric\"]:\n            raise ValueError(\"Parameter 'truncate' must be 'no', 'negatives', or 'symmetric'.\")\n\n        roots, weights = self._gaussian_weights(\n            int(number_of_components), float(mean_radius), float(standard_deviation)\n        )\n\n        if truncate == \"negatives\":\n            roots_to_remove = roots &lt; 0\n        elif truncate == \"symmetric\":\n            roots_to_remove = np.abs(roots - mean_radius) &gt; mean_radius\n        else:\n            roots_to_remove = np.full_like(roots, False, dtype=bool)\n\n        if np.any(roots_to_remove):\n            roots_to_keep = ~roots_to_remove\n            number_of_components_new = np.count_nonzero(roots_to_keep)\n            roots = roots[roots_to_keep]\n            weights = weights[roots_to_keep]\n\n            logger.warning(\n                f\"Components with unphysical radii were removed. Number of components \"\n                f\"was reduced from {number_of_components} to {number_of_components_new}.\"\n            )\n\n        super().__init__(roots, weights)\n\n    @staticmethod\n    def _gaussian_weights(\n        number_of_components: int, mean_radius: float, standard_deviation: float\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        roots, weights = roots_hermite(number_of_components)\n        scaled_roots = roots * np.sqrt(2) * standard_deviation + mean_radius\n        weights /= np.sum(weights)\n        return scaled_roots, weights\n</code></pre>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture","title":"<code>Mixture</code>","text":"<p>Representation of the size distribution of an N-component mixture of spherical particles.</p> <p>Such a mixture can be interpreted as a collection of spheres with a discrete probability distribution of the radii, where the number fraction of each species describes their respective weight.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>ArrayLike</code> <p>The physical, geometric radius of each component.</p> required <code>number_fraction</code> <code>ArrayLike</code> <p>Number fraction of each component.</p> required <code>normalize_number_fraction</code> <code>bool</code> <p>If True, <code>number_fraction</code> will be explicitly normalized                        such that the sum over all elements equals 1.</p> <code>True</code> Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>class Mixture:\n    \"\"\"Representation of the size distribution of an N-component mixture of spherical particles.\n\n    Such a mixture can be interpreted as a collection of spheres with a discrete probability\n    distribution of the radii, where the number fraction of each species describes their\n    respective weight.\n\n    Args:\n        radius: The physical, geometric radius of each component.\n        number_fraction: Number fraction of each component.\n        normalize_number_fraction: If True, `number_fraction` will be explicitly normalized\n                                   such that the sum over all elements equals 1.\n    \"\"\"\n\n    def __init__(self, radius: ArrayLike, number_fraction: ArrayLike, normalize_number_fraction: bool = True) -&gt; None:\n        self._radius: NDArray[np.float64] = np.asarray(radius, dtype=np.float64)\n        self._number_fraction: NDArray[np.float64] = np.asarray(number_fraction, dtype=np.float64)\n\n        if normalize_number_fraction:\n            self._number_fraction /= np.sum(self._number_fraction)\n\n        self._number_of_components: int = len(self._radius)\n\n    @property\n    def radius(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get an array of the radii of each component.\n\n        Returns:\n            An array of the radii.\n        \"\"\"\n        return self._radius\n\n    @radius.setter\n    def radius(self, radius_array: ArrayLike) -&gt; None:\n        \"\"\"\n        Set new `radius`.\n\n        Args:\n            radius_array: New radius array of the same shape as the current radius array.\n        \"\"\"\n        new_array: NDArray[np.float64] = np.asarray(radius_array, dtype=np.float64)\n        if self._radius.shape != new_array.shape:\n            raise ValueError(\"The new radius array must be of same shape as the current radius array.\")\n        self._radius = new_array\n\n    @property\n    def number_fraction(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get an array of the number fractions of each component\n\n        Returns:\n            An array of the number fractions.\n        \"\"\"\n        return self._number_fraction\n\n    @number_fraction.setter\n    def number_fraction(self, number_fraction_array: ArrayLike) -&gt; None:\n        \"\"\"\n        Set new `number_fraction`.\n\n        Args:\n            number_fraction_array:\n        \"\"\"\n        new_array: NDArray[np.float64] = np.asarray(number_fraction_array, dtype=np.float64)\n        if self._number_fraction.shape != new_array.shape:\n            raise ValueError(\n                \"The new number fraction array must be of same shape as the current number fraction array.\"\n            )\n        self._number_fraction = new_array\n\n    @property\n    def number_of_components(self) -&gt; int:\n        \"\"\"\n        Get the number of components of the mixture.\n\n        Returns:\n            The number of components.\n        \"\"\"\n        return self._number_of_components\n\n    def moment(self, order: int) -&gt; float:\n        \"\"\"Calculate the moment of the specified order.\n\n        Args:\n            order: Order of the moment to calculate.\n\n        Returns:\n            The moment of the specified order.\n        \"\"\"\n        return float(np.sum(self.number_fraction * self.radius**order))\n\n    def central_moment(self, order: int) -&gt; float:\n        \"\"\"Calculate the central moment of the specified order.\n\n        Args:\n            order: Order of the central moment to calculate.\n\n        Returns:\n            The central moment of the specified order.\n        \"\"\"\n        return float(np.sum(self.number_fraction * (self.radius - self.mean) ** order))\n\n    @property\n    def mean(self) -&gt; float:\n        \"\"\"\n        Calculate the first moment (mean) of the distribution.\n\n        Returns:\n            The mean of the distribution.\n        \"\"\"\n        return self.moment(1)\n\n    @property\n    def variance(self) -&gt; float:\n        \"\"\"\n        Calculate the second central moment (variance) of the distribution.\n\n        Returns:\n            The variance of the distribution.\n        \"\"\"\n        return self.central_moment(2)\n\n    @property\n    def polydispersity(self) -&gt; float:\n        \"\"\"\n        Calculate the polydispersity, which is the ratio of the standard deviation\n        of the distribution to its mean.\n\n        Returns:\n            The polydispersity of the distribution.\n        \"\"\"\n        return float(np.sqrt(self.variance)) / self.mean\n</code></pre>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.mean","title":"<code>mean</code>  <code>property</code>","text":"<p>Calculate the first moment (mean) of the distribution.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mean of the distribution.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.number_fraction","title":"<code>number_fraction</code>  <code>property</code> <code>writable</code>","text":"<p>Get an array of the number fractions of each component</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the number fractions.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.number_of_components","title":"<code>number_of_components</code>  <code>property</code>","text":"<p>Get the number of components of the mixture.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of components.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.polydispersity","title":"<code>polydispersity</code>  <code>property</code>","text":"<p>Calculate the polydispersity, which is the ratio of the standard deviation of the distribution to its mean.</p> <p>Returns:</p> Type Description <code>float</code> <p>The polydispersity of the distribution.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.radius","title":"<code>radius</code>  <code>property</code> <code>writable</code>","text":"<p>Get an array of the radii of each component.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of the radii.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.variance","title":"<code>variance</code>  <code>property</code>","text":"<p>Calculate the second central moment (variance) of the distribution.</p> <p>Returns:</p> Type Description <code>float</code> <p>The variance of the distribution.</p>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.central_moment","title":"<code>central_moment(order)</code>","text":"<p>Calculate the central moment of the specified order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>Order of the central moment to calculate.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The central moment of the specified order.</p> Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>def central_moment(self, order: int) -&gt; float:\n    \"\"\"Calculate the central moment of the specified order.\n\n    Args:\n        order: Order of the central moment to calculate.\n\n    Returns:\n        The central moment of the specified order.\n    \"\"\"\n    return float(np.sum(self.number_fraction * (self.radius - self.mean) ** order))\n</code></pre>"},{"location":"api/mixture_api/#mixscatter.mixture.Mixture.moment","title":"<code>moment(order)</code>","text":"<p>Calculate the moment of the specified order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>Order of the moment to calculate.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The moment of the specified order.</p> Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>def moment(self, order: int) -&gt; float:\n    \"\"\"Calculate the moment of the specified order.\n\n    Args:\n        order: Order of the moment to calculate.\n\n    Returns:\n        The moment of the specified order.\n    \"\"\"\n    return float(np.sum(self.number_fraction * self.radius**order))\n</code></pre>"},{"location":"api/mixture_api/#mixscatter.mixture.SingleComponent","title":"<code>SingleComponent</code>","text":"<p>               Bases: <code>Mixture</code></p> <p>Representation of a pseudo one-component system.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius.</p> required Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>class SingleComponent(Mixture):\n    \"\"\"Representation of a pseudo one-component system.\n\n    Args:\n        radius: Radius.\n    \"\"\"\n\n    def __init__(self, radius: float) -&gt; None:\n        super().__init__([radius], [1.0])\n</code></pre>"},{"location":"api/mixture_api/#mixscatter.mixture.UniformMixture","title":"<code>UniformMixture</code>","text":"<p>               Bases: <code>Mixture</code></p> <p>Representation of a uniformly distributed mixture.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_components</code> <code>int</code> <p>Number of components in the mixture.</p> required <code>lower_bound</code> <code>float</code> <p>Lower bound of the distribution domain.</p> required <code>upper_bound</code> <code>float</code> <p>Upper bound of the distribution domain.</p> required Source code in <code>src/mixscatter/mixture/mixture.py</code> <pre><code>class UniformMixture(Mixture):\n    \"\"\"Representation of a uniformly distributed mixture.\n\n    Args:\n        number_of_components: Number of components in the mixture.\n        lower_bound: Lower bound of the distribution domain.\n        upper_bound: Upper bound of the distribution domain.\n    \"\"\"\n\n    def __init__(self, number_of_components: int, lower_bound: float, upper_bound: float) -&gt; None:\n        roots, weights = self._uniform_weights(int(number_of_components), float(upper_bound), float(lower_bound))\n        super().__init__(roots, weights)\n\n    @staticmethod\n    def _uniform_weights(\n        number_of_components: int, lower_bound: float, upper_bound: float\n    ) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        roots, weights = roots_legendre(number_of_components)\n        scaled_roots = upper_bound * 0.5 * (roots + 1) - lower_bound * 0.5 * (roots - 1)\n        weights /= np.sum(weights)\n        return scaled_roots, weights\n</code></pre>"},{"location":"api/scatteringmodel_api/","title":"scatteringmodel API","text":""},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel","title":"<code>mixscatter.scatteringmodel</code>","text":"<p>Calculate form factors of multicomponent systems.</p> <p>This module provides classes and functions for calculating form factors of multicomponent systems. It includes definitions for various layer profiles, particles composed of these layers, and models to calculate scattering properties for these particles.</p> <p>Classes:</p> Name Description <code>LayerProfile</code> <p>Defines the interface for layer profiles.</p> <code>EmptyProfile</code> <p>Represents an empty layer profile.</p> <code>ConstantProfile</code> <p>Represents a layer profile with constant contrast.</p> <code>LinearProfile</code> <p>Represents a layer profile with linearly varying contrast.</p> <code>Particle</code> <p>Represents a particle composed of multiple layers.</p> <code>ParticleBuilder</code> <p>A builder class for constructing Particle instances.</p> <code>ScatteringModel</code> <p>Calculates scattering properties for a list of particles.</p> <code>SimpleSphere</code> <p>A convenience class for creating a scattering model of homogeneously scattering spheres.</p> <code>SimpleCoreShell</code> <p>A convenience class for creating a scattering model of core-shell particles.</p> <code>SimpleGradient</code> <p>A convenience class for creating a scattering model with gradient profiles.</p> <p>Examples:</p> <p>Create a simple scattering model for spheres:</p> <pre><code>&gt;&gt;&gt; from mixscatter.mixture import Mixture\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n&gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n&gt;&gt;&gt; model = SimpleSphere(wavevector, mixture, contrast=1.0)\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre> <p>Create a core-shell particle model:</p> <pre><code>&gt;&gt;&gt; model = SimpleCoreShell(wavevector, mixture, core_to_total_ratio=0.5, core_contrast=1.0, shell_contrast=0.5)\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre> <p>Create a gradient profile particle model:</p> <pre><code>&gt;&gt;&gt; model = SimpleGradient(wavevector, mixture, center_contrast=1.0, boundary_contrast=0.5)\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ConstantProfile","title":"<code>ConstantProfile</code>","text":"<p>               Bases: <code>LayerProfile</code></p> <p>Represents a layer profile with constant contrast.</p> <p>Attributes:</p> Name Type Description <code>radius_inner</code> <code>float</code> <p>Inner radius of the layer.</p> <code>radius_outer</code> <code>float</code> <p>Outer radius of the layer.</p> <code>contrast</code> <code>float</code> <p>Scattering contrast of the layer.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize a constant layer profile.</p> <code>calculate_amplitude</code> <p>Calculate the amplitude for the given wavevector.</p> <code>calculate_forward_amplitude</code> <p>Calculate the forward amplitude.</p> <code>get_profile</code> <p>Get the profile for the given distance from the origin.</p> <code>calculate_second_moment</code> <p>Calculate the second moment.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class ConstantProfile(LayerProfile):\n    \"\"\"\n    Represents a layer profile with constant contrast.\n\n    Attributes:\n        radius_inner (float): Inner radius of the layer.\n        radius_outer (float): Outer radius of the layer.\n        contrast (float): Scattering contrast of the layer.\n\n    Methods:\n        __init__(radius_inner, radius_outer, contrast):\n            Initialize a constant layer profile.\n\n        calculate_amplitude(wavevector):\n            Calculate the amplitude for the given wavevector.\n\n        calculate_forward_amplitude():\n            Calculate the forward amplitude.\n\n        get_profile(distance):\n            Get the profile for the given distance from the origin.\n\n        calculate_second_moment():\n            Calculate the second moment.\n    \"\"\"\n\n    def __init__(self, radius_inner: float, radius_outer: float, contrast: float) -&gt; None:\n        \"\"\"\n        Initialize a constant layer profile.\n\n        Args:\n            radius_inner: Inner radius of the layer.\n            radius_outer: Outer radius of the layer.\n            contrast: Scattering contrast of the layer.\n\n        Raises:\n            RuntimeError: If `radius_inner` is greater than `radius_outer`.\n        \"\"\"\n        if radius_inner &gt; radius_outer:\n            raise RuntimeError(\"'radius_inner' must be smaller than 'radius_outer'.\")\n\n        self.radius_inner = radius_inner\n        self.radius_outer = radius_outer\n        self.contrast = contrast\n\n    def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Calculate the amplitude for the given wavevector.\n\n        Args:\n            wavevector: Scattering wavevector.\n\n        Returns:\n            Calculated amplitude array.\n        \"\"\"\n        wavevector = np.asarray(wavevector, dtype=np.float64)\n        QR_outer = wavevector * self.radius_outer\n        QR_inner = wavevector * self.radius_inner\n        amplitude: NDArray[np.float64] = np.sin(QR_outer) - QR_outer * np.cos(QR_outer)\n        amplitude -= np.sin(QR_inner) - QR_inner * np.cos(QR_inner)\n        amplitude *= 4.0 * np.pi / wavevector**3 * self.contrast\n        return amplitude\n\n    def calculate_forward_amplitude(self) -&gt; float:\n        \"\"\"Calculate the forward amplitude.\n\n        Returns:\n            The calculated forward amplitude.\n        \"\"\"\n        return 4.0 / 3.0 * np.pi * (self.radius_outer**3 - self.radius_inner**3) * self.contrast\n\n    def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Get the profile for the given distance from the origin.\n\n        Args:\n            distance: Distance from the origin.\n\n        Returns:\n            The profile evaluated on the distance array.\n        \"\"\"\n        distance = np.asarray(distance, dtype=np.float64)\n        distance_mask = (distance &gt;= self.radius_inner) &amp; (distance &lt; self.radius_outer)\n        return np.where(distance_mask, self.contrast, 0.0)\n\n    def calculate_second_moment(self) -&gt; float:\n        \"\"\"Calculate the second moment.\n\n        Returns:\n            The calculated second moment.\n        \"\"\"\n        return 4.0 / 5.0 * np.pi * (self.radius_outer**5 - self.radius_inner**5) * self.contrast\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ConstantProfile.__init__","title":"<code>__init__(radius_inner, radius_outer, contrast)</code>","text":"<p>Initialize a constant layer profile.</p> <p>Parameters:</p> Name Type Description Default <code>radius_inner</code> <code>float</code> <p>Inner radius of the layer.</p> required <code>radius_outer</code> <code>float</code> <p>Outer radius of the layer.</p> required <code>contrast</code> <code>float</code> <p>Scattering contrast of the layer.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>radius_inner</code> is greater than <code>radius_outer</code>.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self, radius_inner: float, radius_outer: float, contrast: float) -&gt; None:\n    \"\"\"\n    Initialize a constant layer profile.\n\n    Args:\n        radius_inner: Inner radius of the layer.\n        radius_outer: Outer radius of the layer.\n        contrast: Scattering contrast of the layer.\n\n    Raises:\n        RuntimeError: If `radius_inner` is greater than `radius_outer`.\n    \"\"\"\n    if radius_inner &gt; radius_outer:\n        raise RuntimeError(\"'radius_inner' must be smaller than 'radius_outer'.\")\n\n    self.radius_inner = radius_inner\n    self.radius_outer = radius_outer\n    self.contrast = contrast\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ConstantProfile.calculate_amplitude","title":"<code>calculate_amplitude(wavevector)</code>","text":"<p>Calculate the amplitude for the given wavevector.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Calculated amplitude array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Calculate the amplitude for the given wavevector.\n\n    Args:\n        wavevector: Scattering wavevector.\n\n    Returns:\n        Calculated amplitude array.\n    \"\"\"\n    wavevector = np.asarray(wavevector, dtype=np.float64)\n    QR_outer = wavevector * self.radius_outer\n    QR_inner = wavevector * self.radius_inner\n    amplitude: NDArray[np.float64] = np.sin(QR_outer) - QR_outer * np.cos(QR_outer)\n    amplitude -= np.sin(QR_inner) - QR_inner * np.cos(QR_inner)\n    amplitude *= 4.0 * np.pi / wavevector**3 * self.contrast\n    return amplitude\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ConstantProfile.calculate_forward_amplitude","title":"<code>calculate_forward_amplitude()</code>","text":"<p>Calculate the forward amplitude.</p> <p>Returns:</p> Type Description <code>float</code> <p>The calculated forward amplitude.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_forward_amplitude(self) -&gt; float:\n    \"\"\"Calculate the forward amplitude.\n\n    Returns:\n        The calculated forward amplitude.\n    \"\"\"\n    return 4.0 / 3.0 * np.pi * (self.radius_outer**3 - self.radius_inner**3) * self.contrast\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ConstantProfile.calculate_second_moment","title":"<code>calculate_second_moment()</code>","text":"<p>Calculate the second moment.</p> <p>Returns:</p> Type Description <code>float</code> <p>The calculated second moment.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_second_moment(self) -&gt; float:\n    \"\"\"Calculate the second moment.\n\n    Returns:\n        The calculated second moment.\n    \"\"\"\n    return 4.0 / 5.0 * np.pi * (self.radius_outer**5 - self.radius_inner**5) * self.contrast\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ConstantProfile.get_profile","title":"<code>get_profile(distance)</code>","text":"<p>Get the profile for the given distance from the origin.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>ArrayLike</code> <p>Distance from the origin.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The profile evaluated on the distance array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Get the profile for the given distance from the origin.\n\n    Args:\n        distance: Distance from the origin.\n\n    Returns:\n        The profile evaluated on the distance array.\n    \"\"\"\n    distance = np.asarray(distance, dtype=np.float64)\n    distance_mask = (distance &gt;= self.radius_inner) &amp; (distance &lt; self.radius_outer)\n    return np.where(distance_mask, self.contrast, 0.0)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.EmptyProfile","title":"<code>EmptyProfile</code>","text":"<p>               Bases: <code>LayerProfile</code></p> <p>Represents an empty layer profile.</p> <p>Attributes:</p> Name Type Description <code>radius_inner</code> <code>float</code> <p>Inner radius of the empty layer.</p> <code>radius_outer</code> <code>float</code> <p>Outer radius of the empty layer.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize an empty layer profile.</p> <code>calculate_amplitude</code> <p>Calculate the amplitude for the given wavevector.</p> <code>calculate_forward_amplitude</code> <p>Calculate the forward amplitude.</p> <code>get_profile</code> <p>Get the profile for the given distance from the origin.</p> <code>calculate_second_moment</code> <p>Calculate the second moment.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class EmptyProfile(LayerProfile):\n    \"\"\"\n    Represents an empty layer profile.\n\n    Attributes:\n        radius_inner (float): Inner radius of the empty layer.\n        radius_outer (float): Outer radius of the empty layer.\n\n    Methods:\n        __init__(radius_inner, radius_outer):\n            Initialize an empty layer profile.\n\n        calculate_amplitude(wavevector):\n            Calculate the amplitude for the given wavevector.\n\n        calculate_forward_amplitude():\n            Calculate the forward amplitude.\n\n        get_profile(distance):\n            Get the profile for the given distance from the origin.\n\n        calculate_second_moment():\n            Calculate the second moment.\n    \"\"\"\n\n    def __init__(self, radius_inner: float, radius_outer: float) -&gt; None:\n        \"\"\"\n        Initialize an empty layer profile.\n\n        Args:\n            radius_inner: Inner radius of the empty layer.\n            radius_outer: Outer radius of the empty layer.\n\n        Raises:\n            RuntimeError: If `radius_inner` is greater than `radius_outer`.\n        \"\"\"\n        if radius_inner &gt; radius_outer:\n            raise RuntimeError(\"'radius_inner' must be smaller than 'radius_outer'.\")\n\n        self.radius_inner = radius_inner\n        self.radius_outer = radius_outer\n\n    def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Calculate the amplitude for the given wavevector.\n\n        Args:\n            wavevector: Scattering wavevector.\n\n        Returns:\n            Zero array of the same shape as wavevector.\n        \"\"\"\n        wavevector = np.asarray(wavevector, dtype=np.float64)\n        return np.zeros_like(wavevector)\n\n    def calculate_forward_amplitude(self) -&gt; float:\n        \"\"\"Calculate the forward amplitude.\n\n        Returns:\n            Zero.\n        \"\"\"\n        return 0.0\n\n    def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get the profile for the given distance from the origin.\n\n        Args:\n            distance: Distance from the origin.\n\n        Returns:\n            Zero array of the same shape as distance.\n        \"\"\"\n        distance = np.asarray(distance, dtype=np.float64)\n        return np.zeros_like(distance)\n\n    def calculate_second_moment(self) -&gt; float:\n        \"\"\"Calculate the second moment.\n\n        Returns:\n            Zero.\n        \"\"\"\n        return 0.0\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.EmptyProfile.__init__","title":"<code>__init__(radius_inner, radius_outer)</code>","text":"<p>Initialize an empty layer profile.</p> <p>Parameters:</p> Name Type Description Default <code>radius_inner</code> <code>float</code> <p>Inner radius of the empty layer.</p> required <code>radius_outer</code> <code>float</code> <p>Outer radius of the empty layer.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>radius_inner</code> is greater than <code>radius_outer</code>.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self, radius_inner: float, radius_outer: float) -&gt; None:\n    \"\"\"\n    Initialize an empty layer profile.\n\n    Args:\n        radius_inner: Inner radius of the empty layer.\n        radius_outer: Outer radius of the empty layer.\n\n    Raises:\n        RuntimeError: If `radius_inner` is greater than `radius_outer`.\n    \"\"\"\n    if radius_inner &gt; radius_outer:\n        raise RuntimeError(\"'radius_inner' must be smaller than 'radius_outer'.\")\n\n    self.radius_inner = radius_inner\n    self.radius_outer = radius_outer\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.EmptyProfile.calculate_amplitude","title":"<code>calculate_amplitude(wavevector)</code>","text":"<p>Calculate the amplitude for the given wavevector.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Zero array of the same shape as wavevector.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Calculate the amplitude for the given wavevector.\n\n    Args:\n        wavevector: Scattering wavevector.\n\n    Returns:\n        Zero array of the same shape as wavevector.\n    \"\"\"\n    wavevector = np.asarray(wavevector, dtype=np.float64)\n    return np.zeros_like(wavevector)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.EmptyProfile.calculate_forward_amplitude","title":"<code>calculate_forward_amplitude()</code>","text":"<p>Calculate the forward amplitude.</p> <p>Returns:</p> Type Description <code>float</code> <p>Zero.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_forward_amplitude(self) -&gt; float:\n    \"\"\"Calculate the forward amplitude.\n\n    Returns:\n        Zero.\n    \"\"\"\n    return 0.0\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.EmptyProfile.calculate_second_moment","title":"<code>calculate_second_moment()</code>","text":"<p>Calculate the second moment.</p> <p>Returns:</p> Type Description <code>float</code> <p>Zero.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_second_moment(self) -&gt; float:\n    \"\"\"Calculate the second moment.\n\n    Returns:\n        Zero.\n    \"\"\"\n    return 0.0\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.EmptyProfile.get_profile","title":"<code>get_profile(distance)</code>","text":"<p>Get the profile for the given distance from the origin.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>ArrayLike</code> <p>Distance from the origin.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Zero array of the same shape as distance.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Get the profile for the given distance from the origin.\n\n    Args:\n        distance: Distance from the origin.\n\n    Returns:\n        Zero array of the same shape as distance.\n    \"\"\"\n    distance = np.asarray(distance, dtype=np.float64)\n    return np.zeros_like(distance)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LayerProfile","title":"<code>LayerProfile</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the interface for layer profiles.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class LayerProfile(Protocol):  # pragma: no cover\n    \"\"\"Defines the interface for layer profiles.\"\"\"\n\n    radius_inner: float\n    radius_outer: float\n\n    def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Calculate the amplitude for the given wavevector.\"\"\"\n        ...\n\n    def calculate_forward_amplitude(self) -&gt; float:\n        \"\"\"Calculate the forward amplitude.\"\"\"\n        ...\n\n    def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Get the profile for the given distance from the origin.\"\"\"\n        ...\n\n    def calculate_second_moment(self) -&gt; float:\n        \"\"\"Calculate the second moment.\"\"\"\n        ...\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LayerProfile.calculate_amplitude","title":"<code>calculate_amplitude(wavevector)</code>","text":"<p>Calculate the amplitude for the given wavevector.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Calculate the amplitude for the given wavevector.\"\"\"\n    ...\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LayerProfile.calculate_forward_amplitude","title":"<code>calculate_forward_amplitude()</code>","text":"<p>Calculate the forward amplitude.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_forward_amplitude(self) -&gt; float:\n    \"\"\"Calculate the forward amplitude.\"\"\"\n    ...\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LayerProfile.calculate_second_moment","title":"<code>calculate_second_moment()</code>","text":"<p>Calculate the second moment.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_second_moment(self) -&gt; float:\n    \"\"\"Calculate the second moment.\"\"\"\n    ...\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LayerProfile.get_profile","title":"<code>get_profile(distance)</code>","text":"<p>Get the profile for the given distance from the origin.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Get the profile for the given distance from the origin.\"\"\"\n    ...\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile","title":"<code>LinearProfile</code>","text":"<p>               Bases: <code>LayerProfile</code></p> <p>Represents a layer profile with linearly varying contrast.</p> <p>Attributes:</p> Name Type Description <code>radius_inner</code> <code>float</code> <p>Inner radius of the layer.</p> <code>radius_outer</code> <code>float</code> <p>Outer radius of the layer.</p> <code>contrast_inner</code> <code>float</code> <p>Contrast at the inner radius.</p> <code>contrast_outer</code> <code>float</code> <p>Contrast at the outer radius.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize a linearly varying layer profile.</p> <code>calculate_amplitude</code> <p>Calculate the amplitude for the given wavevector.</p> <code>calculate_forward_amplitude</code> <p>Calculate the forward amplitude.</p> <code>get_profile</code> <p>Get the profile for the given distance from the origin.</p> <code>calculate_second_moment</code> <p>Calculate the second moment.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class LinearProfile(LayerProfile):\n    \"\"\"\n    Represents a layer profile with linearly varying contrast.\n\n    Attributes:\n        radius_inner (float): Inner radius of the layer.\n        radius_outer (float): Outer radius of the layer.\n        contrast_inner (float): Contrast at the inner radius.\n        contrast_outer (float): Contrast at the outer radius.\n\n    Methods:\n        __init__(radius_inner, radius_outer, contrast_inner, contrast_outer):\n            Initialize a linearly varying layer profile.\n\n        calculate_amplitude(wavevector):\n            Calculate the amplitude for the given wavevector.\n\n        calculate_forward_amplitude():\n            Calculate the forward amplitude.\n\n        get_profile(distance):\n            Get the profile for the given distance from the origin.\n\n        calculate_second_moment():\n            Calculate the second moment.\n    \"\"\"\n\n    def __init__(self, radius_inner: float, radius_outer: float, contrast_inner: float, contrast_outer: float) -&gt; None:\n        \"\"\"\n        Initialize a linearly varying layer profile.\n\n        Args:\n            radius_inner (float): Inner radius of the layer.\n            radius_outer (float): Outer radius of the layer.\n            contrast_inner (float): Contrast at the inner radius.\n            contrast_outer (float): Contrast at the outer radius.\n\n        Raises:\n            RuntimeError: If radius_inner is greater than radius_outer.\n        \"\"\"\n        if radius_inner &gt; radius_outer:\n            raise RuntimeError(\"'radius_inner' must be smaller than 'radius_outer'.\")\n\n        self.radius_inner = radius_inner\n        self.radius_outer = radius_outer\n        self.contrast_inner = contrast_inner\n        self.contrast_outer = contrast_outer\n\n    def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Calculate the amplitude for the given wavevector.\n\n        Args:\n            wavevector: Scattering wavevector.\n\n        Returns:\n            The calculated amplitude array.\n        \"\"\"\n        wavevector = np.asarray(wavevector, dtype=np.float64)\n        QR_outer = wavevector * self.radius_outer\n        QR_inner = wavevector * self.radius_inner\n        intercept, slope = self._two_point_to_slope_intercept(\n            self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n        )\n        amplitude_intercept = ConstantProfile(self.radius_inner, self.radius_outer, intercept).calculate_amplitude(\n            wavevector\n        )\n        amplitude_gradient: NDArray[np.float64] = (2.0 - QR_outer**2) * np.cos(QR_outer) + 2.0 * QR_outer * np.sin(\n            QR_outer\n        )\n        amplitude_gradient -= (2.0 - QR_inner**2) * np.cos(QR_inner) + 2.0 * QR_inner * np.sin(QR_inner)\n        amplitude_gradient *= 4.0 * np.pi / wavevector**4 * slope\n        return amplitude_intercept + amplitude_gradient\n\n    def calculate_forward_amplitude(self) -&gt; float:\n        \"\"\"Calculate the forward amplitude.\n\n        Returns:\n            The calculated forward amplitude.\n        \"\"\"\n        intercept, slope = self._two_point_to_slope_intercept(\n            self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n        )\n        forward_amplitude_intercept = ConstantProfile(\n            self.radius_inner, self.radius_outer, intercept\n        ).calculate_forward_amplitude()\n        forward_amplitude_gradient = np.pi * (self.radius_outer**4 - self.radius_inner**4) * slope\n        return forward_amplitude_intercept + forward_amplitude_gradient\n\n    @staticmethod\n    def _two_point_to_slope_intercept(x_1: float, y_1: float, x_2: float, y_2: float) -&gt; tuple[float, float]:\n        \"\"\"Calculate the slope and intercept for a linear function passing through two points.\n\n        Returns:\n            A tuple containing the intercept and slope.\n        \"\"\"\n        intercept = (x_2 * y_1 - x_1 * y_2) / (x_2 - x_1)\n        slope = (y_2 - y_1) / (x_2 - x_1)\n        return intercept, slope\n\n    def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Get the profile for the given distance from the origin.\n\n        Args:\n            distance: Distance from the origin.\n\n        Returns:\n            The profile evaluated on the distance array.\n        \"\"\"\n        distance = np.asarray(distance, dtype=np.float64)\n        distance_mask = (distance &gt;= self.radius_inner) &amp; (distance &lt; self.radius_outer)\n        intercept, slope = self._two_point_to_slope_intercept(\n            self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n        )\n        profile = np.zeros_like(distance)\n        profile[distance_mask] = intercept + slope * distance[distance_mask]\n        return profile\n\n    def calculate_second_moment(self) -&gt; float:\n        \"\"\"Calculate the second moment.\n\n        Returns:\n            The calculated second moment.\n        \"\"\"\n        intercept, slope = self._two_point_to_slope_intercept(\n            self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n        )\n        moment_intercept = ConstantProfile(self.radius_inner, self.radius_outer, intercept).calculate_second_moment()\n        moment_slope = 2.0 / 3.0 * np.pi * (self.radius_outer**6 - self.radius_inner**6) * slope\n        return moment_intercept + moment_slope\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile.__init__","title":"<code>__init__(radius_inner, radius_outer, contrast_inner, contrast_outer)</code>","text":"<p>Initialize a linearly varying layer profile.</p> <p>Parameters:</p> Name Type Description Default <code>radius_inner</code> <code>float</code> <p>Inner radius of the layer.</p> required <code>radius_outer</code> <code>float</code> <p>Outer radius of the layer.</p> required <code>contrast_inner</code> <code>float</code> <p>Contrast at the inner radius.</p> required <code>contrast_outer</code> <code>float</code> <p>Contrast at the outer radius.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If radius_inner is greater than radius_outer.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self, radius_inner: float, radius_outer: float, contrast_inner: float, contrast_outer: float) -&gt; None:\n    \"\"\"\n    Initialize a linearly varying layer profile.\n\n    Args:\n        radius_inner (float): Inner radius of the layer.\n        radius_outer (float): Outer radius of the layer.\n        contrast_inner (float): Contrast at the inner radius.\n        contrast_outer (float): Contrast at the outer radius.\n\n    Raises:\n        RuntimeError: If radius_inner is greater than radius_outer.\n    \"\"\"\n    if radius_inner &gt; radius_outer:\n        raise RuntimeError(\"'radius_inner' must be smaller than 'radius_outer'.\")\n\n    self.radius_inner = radius_inner\n    self.radius_outer = radius_outer\n    self.contrast_inner = contrast_inner\n    self.contrast_outer = contrast_outer\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile._two_point_to_slope_intercept","title":"<code>_two_point_to_slope_intercept(x_1, y_1, x_2, y_2)</code>  <code>staticmethod</code>","text":"<p>Calculate the slope and intercept for a linear function passing through two points.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple containing the intercept and slope.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>@staticmethod\ndef _two_point_to_slope_intercept(x_1: float, y_1: float, x_2: float, y_2: float) -&gt; tuple[float, float]:\n    \"\"\"Calculate the slope and intercept for a linear function passing through two points.\n\n    Returns:\n        A tuple containing the intercept and slope.\n    \"\"\"\n    intercept = (x_2 * y_1 - x_1 * y_2) / (x_2 - x_1)\n    slope = (y_2 - y_1) / (x_2 - x_1)\n    return intercept, slope\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile.calculate_amplitude","title":"<code>calculate_amplitude(wavevector)</code>","text":"<p>Calculate the amplitude for the given wavevector.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The calculated amplitude array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Calculate the amplitude for the given wavevector.\n\n    Args:\n        wavevector: Scattering wavevector.\n\n    Returns:\n        The calculated amplitude array.\n    \"\"\"\n    wavevector = np.asarray(wavevector, dtype=np.float64)\n    QR_outer = wavevector * self.radius_outer\n    QR_inner = wavevector * self.radius_inner\n    intercept, slope = self._two_point_to_slope_intercept(\n        self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n    )\n    amplitude_intercept = ConstantProfile(self.radius_inner, self.radius_outer, intercept).calculate_amplitude(\n        wavevector\n    )\n    amplitude_gradient: NDArray[np.float64] = (2.0 - QR_outer**2) * np.cos(QR_outer) + 2.0 * QR_outer * np.sin(\n        QR_outer\n    )\n    amplitude_gradient -= (2.0 - QR_inner**2) * np.cos(QR_inner) + 2.0 * QR_inner * np.sin(QR_inner)\n    amplitude_gradient *= 4.0 * np.pi / wavevector**4 * slope\n    return amplitude_intercept + amplitude_gradient\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile.calculate_forward_amplitude","title":"<code>calculate_forward_amplitude()</code>","text":"<p>Calculate the forward amplitude.</p> <p>Returns:</p> Type Description <code>float</code> <p>The calculated forward amplitude.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_forward_amplitude(self) -&gt; float:\n    \"\"\"Calculate the forward amplitude.\n\n    Returns:\n        The calculated forward amplitude.\n    \"\"\"\n    intercept, slope = self._two_point_to_slope_intercept(\n        self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n    )\n    forward_amplitude_intercept = ConstantProfile(\n        self.radius_inner, self.radius_outer, intercept\n    ).calculate_forward_amplitude()\n    forward_amplitude_gradient = np.pi * (self.radius_outer**4 - self.radius_inner**4) * slope\n    return forward_amplitude_intercept + forward_amplitude_gradient\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile.calculate_second_moment","title":"<code>calculate_second_moment()</code>","text":"<p>Calculate the second moment.</p> <p>Returns:</p> Type Description <code>float</code> <p>The calculated second moment.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_second_moment(self) -&gt; float:\n    \"\"\"Calculate the second moment.\n\n    Returns:\n        The calculated second moment.\n    \"\"\"\n    intercept, slope = self._two_point_to_slope_intercept(\n        self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n    )\n    moment_intercept = ConstantProfile(self.radius_inner, self.radius_outer, intercept).calculate_second_moment()\n    moment_slope = 2.0 / 3.0 * np.pi * (self.radius_outer**6 - self.radius_inner**6) * slope\n    return moment_intercept + moment_slope\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.LinearProfile.get_profile","title":"<code>get_profile(distance)</code>","text":"<p>Get the profile for the given distance from the origin.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>ArrayLike</code> <p>Distance from the origin.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The profile evaluated on the distance array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Get the profile for the given distance from the origin.\n\n    Args:\n        distance: Distance from the origin.\n\n    Returns:\n        The profile evaluated on the distance array.\n    \"\"\"\n    distance = np.asarray(distance, dtype=np.float64)\n    distance_mask = (distance &gt;= self.radius_inner) &amp; (distance &lt; self.radius_outer)\n    intercept, slope = self._two_point_to_slope_intercept(\n        self.radius_inner, self.contrast_inner, self.radius_outer, self.contrast_outer\n    )\n    profile = np.zeros_like(distance)\n    profile[distance_mask] = intercept + slope * distance[distance_mask]\n    return profile\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle","title":"<code>Particle</code>","text":"<p>Represents a particle composed of multiple layers.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>list</code> <p>List of <code>LayerProfile</code> instances representing particle layers.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize a particle with given layers.</p> <code>calculate_amplitude</code> <p>Calculate the amplitude for the given wavevector.</p> <code>calculate_forward_amplitude</code> <p>Calculate the forward amplitude.</p> <code>calculate_form_factor</code> <p>Calculate the form factor for the given wavevector.</p> <code>get_profile</code> <p>Get the profile for the given distance from the origin.</p> <code>calculate_square_radius_of_gyration</code> <p>Calculate the squared radius of the gyration.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class Particle:\n    \"\"\"\n    Represents a particle composed of multiple layers.\n\n    Attributes:\n        layers (list): List of `LayerProfile` instances representing particle layers.\n\n    Methods:\n        __init__(layers):\n            Initialize a particle with given layers.\n\n        calculate_amplitude(wavevector):\n            Calculate the amplitude for the given wavevector.\n\n        calculate_forward_amplitude():\n            Calculate the forward amplitude.\n\n        calculate_form_factor(wavevector):\n            Calculate the form factor for the given wavevector.\n\n        get_profile(distance):\n            Get the profile for the given distance from the origin.\n\n        calculate_square_radius_of_gyration():\n            Calculate the squared radius of the gyration.\n    \"\"\"\n\n    def __init__(self, layers: list[LayerProfile]) -&gt; None:\n        \"\"\"\n        Initialize a particle with given layers.\n\n        Args:\n            layers: List of `LayerProfile` instances representing particle layers.\n        \"\"\"\n        self.layers = layers\n\n    def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Calculate the amplitude for the given wavevector.\n\n        Args:\n            wavevector: Scattering wavevector.\n\n        Returns:\n            The calculated amplitude array.\n        \"\"\"\n        wavevector = np.asarray(wavevector, dtype=np.float64)\n        amplitude = np.zeros_like(wavevector)\n        for layer in self.layers:\n            amplitude += layer.calculate_amplitude(wavevector)\n        return amplitude\n\n    def calculate_forward_amplitude(self) -&gt; float:\n        \"\"\"Calculate the forward amplitude.\n\n        Returns:\n            The calculated forward amplitude.\n        \"\"\"\n        forward_amplitude = 0.0\n        for layer in self.layers:\n            forward_amplitude += layer.calculate_forward_amplitude()\n        return forward_amplitude\n\n    def calculate_form_factor(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Calculate the form factor for the given wavevector.\n\n        Args:\n            wavevector: Scattering wavevector.\n\n        Returns:\n            The calculated form factor array.\n        \"\"\"\n        wavevector = np.asarray(wavevector, dtype=np.float64)\n        amplitude = self.calculate_amplitude(wavevector)\n        forward_amplitude = self.calculate_forward_amplitude()\n        return (amplitude / forward_amplitude) ** 2.0\n\n    def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n        \"\"\"Get the profile for the given distance from the origin.\n\n        Args:\n            distance: Distance from the origin.\n\n        Returns:\n            The profile evaluated on the distance array.\n        \"\"\"\n        distance = np.asarray(distance, dtype=np.float64)\n        profile = np.zeros_like(distance)\n        for layer in self.layers:\n            profile += layer.get_profile(distance)\n        return profile\n\n    def calculate_square_radius_of_gyration(self) -&gt; float:\n        \"\"\"Calculate the squared radius of the gyration.\n        Returns:\n            The calculated squared radius of the gyration.\n        \"\"\"\n        total_second_moment = 0.0\n        for layer in self.layers:\n            total_second_moment += layer.calculate_second_moment()\n        square_radius_of_gyration = total_second_moment / self.calculate_forward_amplitude()\n        return square_radius_of_gyration\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle.__init__","title":"<code>__init__(layers)</code>","text":"<p>Initialize a particle with given layers.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[LayerProfile]</code> <p>List of <code>LayerProfile</code> instances representing particle layers.</p> required Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self, layers: list[LayerProfile]) -&gt; None:\n    \"\"\"\n    Initialize a particle with given layers.\n\n    Args:\n        layers: List of `LayerProfile` instances representing particle layers.\n    \"\"\"\n    self.layers = layers\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle.calculate_amplitude","title":"<code>calculate_amplitude(wavevector)</code>","text":"<p>Calculate the amplitude for the given wavevector.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The calculated amplitude array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_amplitude(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Calculate the amplitude for the given wavevector.\n\n    Args:\n        wavevector: Scattering wavevector.\n\n    Returns:\n        The calculated amplitude array.\n    \"\"\"\n    wavevector = np.asarray(wavevector, dtype=np.float64)\n    amplitude = np.zeros_like(wavevector)\n    for layer in self.layers:\n        amplitude += layer.calculate_amplitude(wavevector)\n    return amplitude\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle.calculate_form_factor","title":"<code>calculate_form_factor(wavevector)</code>","text":"<p>Calculate the form factor for the given wavevector.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Scattering wavevector.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The calculated form factor array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_form_factor(self, wavevector: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Calculate the form factor for the given wavevector.\n\n    Args:\n        wavevector: Scattering wavevector.\n\n    Returns:\n        The calculated form factor array.\n    \"\"\"\n    wavevector = np.asarray(wavevector, dtype=np.float64)\n    amplitude = self.calculate_amplitude(wavevector)\n    forward_amplitude = self.calculate_forward_amplitude()\n    return (amplitude / forward_amplitude) ** 2.0\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle.calculate_forward_amplitude","title":"<code>calculate_forward_amplitude()</code>","text":"<p>Calculate the forward amplitude.</p> <p>Returns:</p> Type Description <code>float</code> <p>The calculated forward amplitude.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_forward_amplitude(self) -&gt; float:\n    \"\"\"Calculate the forward amplitude.\n\n    Returns:\n        The calculated forward amplitude.\n    \"\"\"\n    forward_amplitude = 0.0\n    for layer in self.layers:\n        forward_amplitude += layer.calculate_forward_amplitude()\n    return forward_amplitude\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle.calculate_square_radius_of_gyration","title":"<code>calculate_square_radius_of_gyration()</code>","text":"<p>Calculate the squared radius of the gyration. Returns:     The calculated squared radius of the gyration.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def calculate_square_radius_of_gyration(self) -&gt; float:\n    \"\"\"Calculate the squared radius of the gyration.\n    Returns:\n        The calculated squared radius of the gyration.\n    \"\"\"\n    total_second_moment = 0.0\n    for layer in self.layers:\n        total_second_moment += layer.calculate_second_moment()\n    square_radius_of_gyration = total_second_moment / self.calculate_forward_amplitude()\n    return square_radius_of_gyration\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.Particle.get_profile","title":"<code>get_profile(distance)</code>","text":"<p>Get the profile for the given distance from the origin.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>ArrayLike</code> <p>Distance from the origin.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The profile evaluated on the distance array.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def get_profile(self, distance: ArrayLike) -&gt; NDArray[np.float64]:\n    \"\"\"Get the profile for the given distance from the origin.\n\n    Args:\n        distance: Distance from the origin.\n\n    Returns:\n        The profile evaluated on the distance array.\n    \"\"\"\n    distance = np.asarray(distance, dtype=np.float64)\n    profile = np.zeros_like(distance)\n    for layer in self.layers:\n        profile += layer.get_profile(distance)\n    return profile\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ParticleBuilder","title":"<code>ParticleBuilder</code>","text":"<p>A builder class for constructing <code>Particle</code> instances.</p> <p>This class facilitates the step-by-step construction of <code>Particle</code> objects composed of multiple layers, where each layer is represented by a <code>LayerProfile</code> instance. The builder ensures that layers are added sequentially, with checks for connectivity between layers and overlap prevention.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>list</code> <p>List to store <code>LayerProfile</code> instances representing the layers of the particle.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes an empty <code>ParticleBuilder</code> instance.</p> <code>add_layer</code> <p>Adds a layer to the particle being built. Ensures the new layer connects correctly to the previous layer and does not overlap with existing layers.</p> <code>reset</code> <p>Resets the builder instance, clearing all layers stored in the layers list.</p> <code>get_particle</code> <p>Constructs and returns a <code>Particle</code> instance using the layers added so far.</p> <code>pop_particle</code> <p>Constructs and returns a <code>Particle</code> instance using the layers added so far, then resets the builder instance to start building a new particle.</p> Usage <p>The typical usage involves creating a <code>ParticleBuilder</code> instance, adding layers using add_layer(), and finally retrieving the constructed particle using get_particle() or pop_particle().</p> Example <p>Construct a particle using <code>ParticleBuilder</code>:</p> <pre><code>&gt;&gt;&gt; from mixscatter.scatteringmodel import ParticleBuilder, ConstantProfile\n&gt;&gt;&gt; layer1 = ConstantProfile(radius_inner=0.0, radius_outer=2.0, contrast=1.0)\n&gt;&gt;&gt; layer2 = ConstantProfile(radius_inner=2.0, radius_outer=5.0, contrast=0.5)\n&gt;&gt;&gt; builder = ParticleBuilder()\n&gt;&gt;&gt; particle = builder.add_layer(layer1).add_layer(layer2).get_particle()\n</code></pre> Notes <ul> <li>The add_layer() method ensures that each added layer starts where the previous layer ends,   preventing gaps or overlaps between layers.</li> <li>The reset() method allows reusing the same builder instance to construct multiple particles.</li> <li>The pop_particle() method is useful when constructing and retrieving particles in a single step,   resetting the builder for the next particle construction.</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Raised by add_layer() method if the added layer does not connect correctly to the previous layer or if there is an overlap with existing layers.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class ParticleBuilder:\n    \"\"\"\n    A builder class for constructing `Particle` instances.\n\n    This class facilitates the step-by-step construction of `Particle` objects composed of multiple\n    layers, where each layer is represented by a `LayerProfile` instance. The builder ensures that layers\n    are added sequentially, with checks for connectivity between layers and overlap prevention.\n\n    Attributes:\n        layers (list): List to store `LayerProfile` instances representing the layers of the particle.\n\n    Methods:\n        __init__():\n            Initializes an empty `ParticleBuilder` instance.\n\n        add_layer(layer):\n            Adds a layer to the particle being built. Ensures the new layer connects correctly to the\n            previous layer and does not overlap with existing layers.\n\n        reset():\n            Resets the builder instance, clearing all layers stored in the layers list.\n\n        get_particle():\n            Constructs and returns a `Particle` instance using the layers added so far.\n\n        pop_particle():\n            Constructs and returns a `Particle` instance using the layers added so far, then resets the\n            builder instance to start building a new particle.\n\n    Usage:\n        The typical usage involves creating a `ParticleBuilder` instance, adding layers using add_layer(),\n        and finally retrieving the constructed particle using get_particle() or pop_particle().\n\n    Example:\n        Construct a particle using `ParticleBuilder`:\n\n            &gt;&gt;&gt; from mixscatter.scatteringmodel import ParticleBuilder, ConstantProfile\n            &gt;&gt;&gt; layer1 = ConstantProfile(radius_inner=0.0, radius_outer=2.0, contrast=1.0)\n            &gt;&gt;&gt; layer2 = ConstantProfile(radius_inner=2.0, radius_outer=5.0, contrast=0.5)\n            &gt;&gt;&gt; builder = ParticleBuilder()\n            &gt;&gt;&gt; particle = builder.add_layer(layer1).add_layer(layer2).get_particle()\n\n    Notes:\n        - The add_layer() method ensures that each added layer starts where the previous layer ends,\n          preventing gaps or overlaps between layers.\n        - The reset() method allows reusing the same builder instance to construct multiple particles.\n        - The pop_particle() method is useful when constructing and retrieving particles in a single step,\n          resetting the builder for the next particle construction.\n\n    Raises:\n        RuntimeError:\n            Raised by add_layer() method if the added layer does not connect correctly to the\n            previous layer or if there is an overlap with existing layers.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes an empty `ParticleBuilder` instance.\"\"\"\n        self.layers: list[LayerProfile] = []\n\n    def add_layer(self, layer: LayerProfile) -&gt; Self:\n        \"\"\"Add a layer to the particle being built.\n\n        Args:\n            layer: `LayerProfile` instance to be added.\n\n        Returns:\n            The builder instance.\n\n        Raises:\n            RuntimeError: If the added layer does not connect to the previous layer or if layers overlap.\n        \"\"\"\n        if self.layers:\n            do_layers_connect = np.allclose(self.layers[-1].radius_outer, layer.radius_inner)\n            if not do_layers_connect:\n                raise RuntimeError(\n                    f\"Added layer with inner radius {layer.radius_inner} does not connect to previous layer's outer \"\n                    f\"radius {self.layers[-1].radius_outer}.\"\n                )\n        self.layers.append(layer)\n        return self\n\n    def reset(self) -&gt; None:\n        \"\"\"Resets the builder instance, clearing all layers stored in the layers list.\"\"\"\n        self.layers = []\n\n    def get_particle(self) -&gt; Particle:\n        \"\"\"\n        Constructs and returns a `Particle` instance using the layers added so far.\n\n        Returns:\n            The constructed `Particle` instance.\n        \"\"\"\n        return Particle(self.layers)\n\n    def pop_particle(self) -&gt; Particle:\n        \"\"\"\n        Constructs and returns a `Particle` instance using the layers added so far,\n        then resets the builder instance to start building a new particle.\n\n        Returns:\n            Particle: The constructed `Particle` instance.\n        \"\"\"\n        particle = Particle(self.layers)\n        self.reset()\n        return particle\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ParticleBuilder.__init__","title":"<code>__init__()</code>","text":"<p>Initializes an empty <code>ParticleBuilder</code> instance.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes an empty `ParticleBuilder` instance.\"\"\"\n    self.layers: list[LayerProfile] = []\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ParticleBuilder.add_layer","title":"<code>add_layer(layer)</code>","text":"<p>Add a layer to the particle being built.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>LayerProfile</code> <p><code>LayerProfile</code> instance to be added.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The builder instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the added layer does not connect to the previous layer or if layers overlap.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def add_layer(self, layer: LayerProfile) -&gt; Self:\n    \"\"\"Add a layer to the particle being built.\n\n    Args:\n        layer: `LayerProfile` instance to be added.\n\n    Returns:\n        The builder instance.\n\n    Raises:\n        RuntimeError: If the added layer does not connect to the previous layer or if layers overlap.\n    \"\"\"\n    if self.layers:\n        do_layers_connect = np.allclose(self.layers[-1].radius_outer, layer.radius_inner)\n        if not do_layers_connect:\n            raise RuntimeError(\n                f\"Added layer with inner radius {layer.radius_inner} does not connect to previous layer's outer \"\n                f\"radius {self.layers[-1].radius_outer}.\"\n            )\n    self.layers.append(layer)\n    return self\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ParticleBuilder.get_particle","title":"<code>get_particle()</code>","text":"<p>Constructs and returns a <code>Particle</code> instance using the layers added so far.</p> <p>Returns:</p> Type Description <code>Particle</code> <p>The constructed <code>Particle</code> instance.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def get_particle(self) -&gt; Particle:\n    \"\"\"\n    Constructs and returns a `Particle` instance using the layers added so far.\n\n    Returns:\n        The constructed `Particle` instance.\n    \"\"\"\n    return Particle(self.layers)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ParticleBuilder.pop_particle","title":"<code>pop_particle()</code>","text":"<p>Constructs and returns a <code>Particle</code> instance using the layers added so far, then resets the builder instance to start building a new particle.</p> <p>Returns:</p> Name Type Description <code>Particle</code> <code>Particle</code> <p>The constructed <code>Particle</code> instance.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def pop_particle(self) -&gt; Particle:\n    \"\"\"\n    Constructs and returns a `Particle` instance using the layers added so far,\n    then resets the builder instance to start building a new particle.\n\n    Returns:\n        Particle: The constructed `Particle` instance.\n    \"\"\"\n    particle = Particle(self.layers)\n    self.reset()\n    return particle\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ParticleBuilder.reset","title":"<code>reset()</code>","text":"<p>Resets the builder instance, clearing all layers stored in the layers list.</p> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the builder instance, clearing all layers stored in the layers list.\"\"\"\n    self.layers = []\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel","title":"<code>ScatteringModel</code>","text":"<p>Calculates scattering properties for a list of particles.</p> <p>This class computes various scattering properties, including amplitudes, form factors, and averages over multiple particles. It handles both single-particle and multi-particle scattering scenarios.</p> <p>Attributes:</p> Name Type Description <code>wavevector</code> <code>NDArray[float64]</code> <p>Array of wavevector values at which scattering properties are computed.</p> <code>mixture</code> <code>MixtureLike</code> <p><code>Mixture</code> object containing number fractions and radii of particle components.</p> <code>particles</code> <code>list</code> <p>List of <code>Particle</code> instances representing the particles in the scattering model.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a <code>ScatteringModel</code> instance with given wavevector, mixture, and particles.</p> Usage <p>The typical usage involves creating an instance of <code>ScatteringModel</code> with wavevector, mixture, and a list of particles. Methods such as amplitude(), average_form_factor(), etc., can then be called to compute specific scattering properties.</p> Example <p>Create a <code>ScatteringModel</code> instance from a list of particles:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture, Particle, ScatteringModel\n&gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n&gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n&gt;&gt;&gt; particle1 = Particle([ConstantProfile(0, 1.0, 1.0)])\n&gt;&gt;&gt; particle2 = Particle([ConstantProfile(0, 2.0, 0.5)])\n&gt;&gt;&gt; model = ScatteringModel(wavevector, mixture, [particle1, particle2])\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre> Notes <ul> <li>Scattering calculations are cached for efficiency.</li> </ul> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class ScatteringModel:\n    # noinspection PyShadowingNames\n    \"\"\"\n    Calculates scattering properties for a list of particles.\n\n    This class computes various scattering properties, including amplitudes, form factors,\n    and averages over multiple particles. It handles both single-particle and multi-particle\n    scattering scenarios.\n\n    Attributes:\n        wavevector (NDArray[np.float64]): Array of wavevector values at which scattering properties are computed.\n        mixture (MixtureLike): `Mixture` object containing number fractions and radii of particle components.\n        particles (list): List of `Particle` instances representing the particles in the scattering model.\n\n    Methods:\n        __init__(wavevector, mixture, particles):\n            Initializes a `ScatteringModel` instance with given wavevector, mixture, and particles.\n\n    Usage:\n        The typical usage involves creating an instance of `ScatteringModel` with wavevector, mixture,\n        and a list of particles. Methods such as amplitude(), average_form_factor(), etc., can then\n        be called to compute specific scattering properties.\n\n    Example:\n        Create a `ScatteringModel` instance from a list of particles:\n\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; from mixscatter import Mixture, Particle, ScatteringModel\n            &gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n            &gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n            &gt;&gt;&gt; particle1 = Particle([ConstantProfile(0, 1.0, 1.0)])\n            &gt;&gt;&gt; particle2 = Particle([ConstantProfile(0, 2.0, 0.5)])\n            &gt;&gt;&gt; model = ScatteringModel(wavevector, mixture, [particle1, particle2])\n            &gt;&gt;&gt; form_factor = model.average_form_factor\n\n    Notes:\n        - Scattering calculations are cached for efficiency.\n    \"\"\"\n\n    def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, particles: list[Particle]):\n        \"\"\"\n        Initializes a `ScatteringModel` instance.\n\n        Args:\n            wavevector: Array of wavevector values at which scattering properties are computed.\n            mixture: Mixture object containing number fractions and radii of particle components.\n            particles: List of `Particle` instances representing the particles in the scattering model.\n        \"\"\"\n        self.wavevector = np.asarray(wavevector, dtype=np.float64)\n        self.mixture = mixture\n        self.particles = particles\n\n    @cached_property\n    def amplitude(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Calculates the scattering amplitude for each particle.\n\n        Returns:\n            Array of amplitudes for each particle at each wavevector point.\n        \"\"\"\n        amplitude = np.empty((len(self.particles), len(self.wavevector)))\n        for i, particle in enumerate(self.particles):\n            amplitude[i] = particle.calculate_amplitude(self.wavevector)\n        return amplitude\n\n    @cached_property\n    def forward_amplitude(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Calculate the forward amplitude for each particle.\n\n        Returns:\n            An array of forward amplitudes for each particle.\n        \"\"\"\n        forward_amplitude = np.empty(len(self.particles))\n        for i, particle in enumerate(self.particles):\n            forward_amplitude[i] = particle.calculate_forward_amplitude()\n        return forward_amplitude\n\n    @cached_property\n    def single_form_factor(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Computes the normalized form factors of the single species particles.\n\n        Returns:\n            Form factors of the single species particles.\n        \"\"\"\n        return self.amplitude**2 / self.forward_amplitude[:, np.newaxis] ** 2\n\n    @cached_property\n    def average_square_amplitude(self) -&gt; NDArray[np.float64]:\n        \"\"\"The sum of the squared scattering amplitudes, weighted by the number fraction.\n\n        Returns:\n            The average squared scattering amplitude.\n        \"\"\"\n        average_square_amplitude: NDArray[np.float64] = np.asanyarray(\n            np.sum(self.mixture.number_fraction[:, np.newaxis] * self.amplitude**2, axis=0), dtype=np.float64\n        )\n        return average_square_amplitude\n\n    @cached_property\n    def average_square_forward_amplitude(self) -&gt; float:\n        \"\"\"The sum of the squared forward scattering amplitudes, weighted by the number fraction.\n\n        Returns:\n            The average squared forward scattering amplitude.\n        \"\"\"\n        average_square_forward_amplitude = float(\n            np.sum(self.mixture.number_fraction * self.forward_amplitude**2, axis=0)\n        )\n        return average_square_forward_amplitude\n\n    @cached_property\n    def average_form_factor(self) -&gt; NDArray[np.float64]:\n        \"\"\"The average squared scattering amplitude, normalized by the average forward scattering amplitude.\n\n        Returns:\n            The average form factor.\n        \"\"\"\n\n        return np.asanyarray(self.average_square_amplitude / self.average_square_forward_amplitude, dtype=np.float64)\n\n    @cached_property\n    def square_radius_of_gyration(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Calculate the radius of gyration for each particle.\n\n        Returns:\n            An array containing the square radius of gyration for each particle.\n        \"\"\"\n        square_radius_of_gyration = np.empty((len(self.particles)))\n        for i, particle in enumerate(self.particles):\n            square_radius_of_gyration[i] = particle.calculate_square_radius_of_gyration()\n        return square_radius_of_gyration\n\n    @cached_property\n    def average_square_radius_of_gyration(self) -&gt; float:\n        \"\"\"\n        Computes the average, apparent radius of gyration of the system. The apparent radius of\n        gyration determines the initial slope of the average form factor.\n\n        Returns:\n             The average radius of gyration of the system.\n        \"\"\"\n        average_square_radius_of_gyration: float = float(\n            np.sum(self.mixture.number_fraction * self.forward_amplitude**2 * self.square_radius_of_gyration, axis=0)\n            / self.average_square_forward_amplitude\n        )\n        return average_square_radius_of_gyration\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.amplitude","title":"<code>amplitude</code>  <code>cached</code> <code>property</code>","text":"<p>Calculates the scattering amplitude for each particle.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of amplitudes for each particle at each wavevector point.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.average_form_factor","title":"<code>average_form_factor</code>  <code>cached</code> <code>property</code>","text":"<p>The average squared scattering amplitude, normalized by the average forward scattering amplitude.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The average form factor.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.average_square_amplitude","title":"<code>average_square_amplitude</code>  <code>cached</code> <code>property</code>","text":"<p>The sum of the squared scattering amplitudes, weighted by the number fraction.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The average squared scattering amplitude.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.average_square_forward_amplitude","title":"<code>average_square_forward_amplitude</code>  <code>cached</code> <code>property</code>","text":"<p>The sum of the squared forward scattering amplitudes, weighted by the number fraction.</p> <p>Returns:</p> Type Description <code>float</code> <p>The average squared forward scattering amplitude.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.average_square_radius_of_gyration","title":"<code>average_square_radius_of_gyration</code>  <code>cached</code> <code>property</code>","text":"<p>Computes the average, apparent radius of gyration of the system. The apparent radius of gyration determines the initial slope of the average form factor.</p> <p>Returns:</p> Type Description <code>float</code> <p>The average radius of gyration of the system.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.forward_amplitude","title":"<code>forward_amplitude</code>  <code>cached</code> <code>property</code>","text":"<p>Calculate the forward amplitude for each particle.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array of forward amplitudes for each particle.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.single_form_factor","title":"<code>single_form_factor</code>  <code>cached</code> <code>property</code>","text":"<p>Computes the normalized form factors of the single species particles.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Form factors of the single species particles.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.square_radius_of_gyration","title":"<code>square_radius_of_gyration</code>  <code>cached</code> <code>property</code>","text":"<p>Calculate the radius of gyration for each particle.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>An array containing the square radius of gyration for each particle.</p>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.ScatteringModel.__init__","title":"<code>__init__(wavevector, mixture, particles)</code>","text":"<p>Initializes a <code>ScatteringModel</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Array of wavevector values at which scattering properties are computed.</p> required <code>mixture</code> <code>MixtureLike</code> <p>Mixture object containing number fractions and radii of particle components.</p> required <code>particles</code> <code>list[Particle]</code> <p>List of <code>Particle</code> instances representing the particles in the scattering model.</p> required Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, particles: list[Particle]):\n    \"\"\"\n    Initializes a `ScatteringModel` instance.\n\n    Args:\n        wavevector: Array of wavevector values at which scattering properties are computed.\n        mixture: Mixture object containing number fractions and radii of particle components.\n        particles: List of `Particle` instances representing the particles in the scattering model.\n    \"\"\"\n    self.wavevector = np.asarray(wavevector, dtype=np.float64)\n    self.mixture = mixture\n    self.particles = particles\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.SimpleCoreShell","title":"<code>SimpleCoreShell</code>","text":"<p>               Bases: <code>ScatteringModel</code></p> <p>A convenience class for creating a scattering model of core-shell particles with a constant core-to-shell ratio.</p> <p>This class simplifies the creation of a scattering model where particles are represented by core-shell structures with varying contrasts for the core and shell layers.</p> <p>Attributes:</p> Name Type Description <code>wavevector</code> <code>NDArray[float64]</code> <p>Array of wavevector values at which scattering properties are computed.</p> <code>mixture</code> <code>MixtureLike</code> <p><code>Mixture</code> object containing number fractions and radii of particle components.</p> <code>particles</code> <code>list</code> <p>List of <code>Particle</code> instances representing the particles in the scattering model.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a <code>SimpleCoreShell</code> instance with given wavevector, mixture, and contrast parameters.</p> Usage <p>The typical usage involves creating an instance of <code>SimpleCoreShell</code> with specific wavevector, mixture, core-shell ratio, and contrast parameters, then using its inherited methods to compute scattering properties.</p> Example <p>Initialize a <code>SimpleCoreShell</code> instance with wavevector, mixture, and contrast parameters</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture, SimpleCoreShell\n&gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n&gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n&gt;&gt;&gt; model = SimpleCoreShell(\n...     wavevector, mixture, core_to_total_ratio=0.5, core_contrast=1.0, shell_contrast=0.5\n... )\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre> Notes <ul> <li>The particle radii are inferred from the provided <code>Mixture</code> instance.</li> </ul> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class SimpleCoreShell(ScatteringModel):\n    # noinspection PyShadowingNames\n    \"\"\"\n    A convenience class for creating a scattering model of core-shell particles with a constant core-to-shell ratio.\n\n    This class simplifies the creation of a scattering model where particles are represented\n    by core-shell structures with varying contrasts for the core and shell layers.\n\n    Attributes:\n        wavevector (NDArray[np.float64]): Array of wavevector values at which scattering properties are computed.\n        mixture (MixtureLike): `Mixture` object containing number fractions and radii of particle components.\n        particles (list): List of `Particle` instances representing the particles in the scattering model.\n\n    Methods:\n        __init__(wavevector, mixture, core_to_total_ratio, core_contrast, shell_contrast):\n            Initializes a `SimpleCoreShell` instance with given wavevector, mixture, and contrast parameters.\n\n    Usage:\n        The typical usage involves creating an instance of `SimpleCoreShell` with specific wavevector, mixture,\n        core-shell ratio, and contrast parameters, then using its inherited methods to compute scattering\n        properties.\n\n    Example:\n        Initialize a `SimpleCoreShell` instance with wavevector, mixture, and contrast parameters\n\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; from mixscatter import Mixture, SimpleCoreShell\n            &gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n            &gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n            &gt;&gt;&gt; model = SimpleCoreShell(\n            ...     wavevector, mixture, core_to_total_ratio=0.5, core_contrast=1.0, shell_contrast=0.5\n            ... )\n            &gt;&gt;&gt; form_factor = model.average_form_factor\n\n    Notes:\n        - The particle radii are inferred from the provided `Mixture` instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        wavevector: ArrayLike,\n        mixture: MixtureLike,\n        core_to_total_ratio: float,\n        core_contrast: float,\n        shell_contrast: float,\n    ) -&gt; None:\n        \"\"\"\n        Initializes a `SimpleCoreShell` instance.\n\n        Args:\n            wavevector: Array of wavevector values at which scattering properties are computed.\n            mixture: `Mixture` object containing number fractions and radii of particle components.\n            core_to_total_ratio: Ratio of core radius to total particle radius.\n            core_contrast: Scattering contrast of the core.\n            shell_contrast: Scattering contrast of the shell.\n        \"\"\"\n        particles = []\n        particle_builder = ParticleBuilder()\n        for total_radius in mixture.radius:\n            core_radius = total_radius * core_to_total_ratio\n            particle = (\n                particle_builder.add_layer(ConstantProfile(0, core_radius, core_contrast))\n                .add_layer(ConstantProfile(core_radius, total_radius, shell_contrast))\n                .pop_particle()\n            )\n            particles.append(particle)\n        super().__init__(wavevector, mixture, particles)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.SimpleCoreShell.__init__","title":"<code>__init__(wavevector, mixture, core_to_total_ratio, core_contrast, shell_contrast)</code>","text":"<p>Initializes a <code>SimpleCoreShell</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Array of wavevector values at which scattering properties are computed.</p> required <code>mixture</code> <code>MixtureLike</code> <p><code>Mixture</code> object containing number fractions and radii of particle components.</p> required <code>core_to_total_ratio</code> <code>float</code> <p>Ratio of core radius to total particle radius.</p> required <code>core_contrast</code> <code>float</code> <p>Scattering contrast of the core.</p> required <code>shell_contrast</code> <code>float</code> <p>Scattering contrast of the shell.</p> required Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(\n    self,\n    wavevector: ArrayLike,\n    mixture: MixtureLike,\n    core_to_total_ratio: float,\n    core_contrast: float,\n    shell_contrast: float,\n) -&gt; None:\n    \"\"\"\n    Initializes a `SimpleCoreShell` instance.\n\n    Args:\n        wavevector: Array of wavevector values at which scattering properties are computed.\n        mixture: `Mixture` object containing number fractions and radii of particle components.\n        core_to_total_ratio: Ratio of core radius to total particle radius.\n        core_contrast: Scattering contrast of the core.\n        shell_contrast: Scattering contrast of the shell.\n    \"\"\"\n    particles = []\n    particle_builder = ParticleBuilder()\n    for total_radius in mixture.radius:\n        core_radius = total_radius * core_to_total_ratio\n        particle = (\n            particle_builder.add_layer(ConstantProfile(0, core_radius, core_contrast))\n            .add_layer(ConstantProfile(core_radius, total_radius, shell_contrast))\n            .pop_particle()\n        )\n        particles.append(particle)\n    super().__init__(wavevector, mixture, particles)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.SimpleGradient","title":"<code>SimpleGradient</code>","text":"<p>               Bases: <code>ScatteringModel</code></p> <p>A convenience class for creating a scattering model of particles with a linear contrast gradient.</p> <p>This class simplifies the creation of a scattering model representing particles with a scattering contrast varying linearly from the contrast at the particle center to the contrast at the boundary.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a <code>SimpleGradient</code> instance with given wavevector, mixture, and center and boundary contrast.</p> Usage <p>The typical usage involves creating an instance of <code>SimpleGradient</code> with specific wavevector, mixture, and contrast profile, then using its inherited methods to compute scattering properties.</p> Example <p>Initialize a <code>SimpleGradient</code> instance with wavevector, mixture, and contrast parameters:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture\n&gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n&gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n&gt;&gt;&gt; model = SimpleGradient(wavevector, mixture, center_contrast=1.0, boundary_contrast=0.5)\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre> Notes <ul> <li>The particle radii are inferred from the provided <code>Mixture</code> instance.</li> </ul> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class SimpleGradient(ScatteringModel):\n    # noinspection PyShadowingNames\n    \"\"\"\n    A convenience class for creating a scattering model of particles with a linear contrast gradient.\n\n    This class simplifies the creation of a scattering model representing particles with a scattering contrast\n    varying linearly from the contrast at the particle center to the contrast at the boundary.\n\n    Methods:\n        __init__(wavevector, mixture, center_contrast, boundary_contrast):\n            Initializes a `SimpleGradient` instance with given wavevector, mixture, and center and boundary\n            contrast.\n\n    Usage:\n        The typical usage involves creating an instance of `SimpleGradient` with specific wavevector, mixture,\n        and contrast profile, then using its inherited methods to compute scattering properties.\n\n    Example:\n        Initialize a `SimpleGradient` instance with wavevector, mixture, and contrast parameters:\n\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; from mixscatter import Mixture\n            &gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n            &gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n            &gt;&gt;&gt; model = SimpleGradient(wavevector, mixture, center_contrast=1.0, boundary_contrast=0.5)\n            &gt;&gt;&gt; form_factor = model.average_form_factor\n\n    Notes:\n        - The particle radii are inferred from the provided `Mixture` instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        wavevector: ArrayLike,\n        mixture: MixtureLike,\n        center_contrast: float,\n        boundary_contrast: float,\n    ) -&gt; None:\n        particles = []\n        particle_builder = ParticleBuilder()\n        for radius in mixture.radius:\n            particle = particle_builder.add_layer(\n                LinearProfile(0, radius, center_contrast, boundary_contrast)\n            ).pop_particle()\n            particles.append(particle)\n        super().__init__(wavevector, mixture, particles)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.SimpleSphere","title":"<code>SimpleSphere</code>","text":"<p>               Bases: <code>ScatteringModel</code></p> <p>A convenience class for creating a scattering model of homogeneously scattering spheres.</p> <p>This class simplifies the creation of a scattering model where particles are represented by homogeneously scattering spheres with a common, constant contrast.</p> <p>Attributes:</p> Name Type Description <code>wavevector</code> <code>NDArray[float64]</code> <p>Array of wavevector values at which scattering properties are computed.</p> <code>mixture</code> <code>MixtureLike</code> <p><code>Mixture</code> object containing number fractions and radii of particle components.</p> <code>particles</code> <code>list</code> <p>List of <code>Particle</code> instances representing the particles in the scattering model.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a <code>SimpleSphere</code> instance with given wavevector, mixture, and contrast.</p> Usage <p>The typical usage involves creating an instance of <code>SimpleSphere</code> with specific wavevector, mixture, and contrast parameters, then using its inherited methods to compute scattering properties.</p> Example <p>Initialize a <code>SimpleSphere</code> instance with wavevector, mixture, and contrast parameters:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from mixscatter import Mixture, SimpleSphere\n&gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n&gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n&gt;&gt;&gt; model = SimpleSphere(wavevector, mixture, contrast=1.0)\n&gt;&gt;&gt; form_factor = model.average_form_factor\n</code></pre> Notes <ul> <li>The particle radii are inferred from the provided <code>Mixture</code> instance.</li> </ul> Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>class SimpleSphere(ScatteringModel):\n    # noinspection PyShadowingNames\n    \"\"\"\n    A convenience class for creating a scattering model of homogeneously scattering spheres.\n\n    This class simplifies the creation of a scattering model where particles are represented\n    by homogeneously scattering spheres with a common, constant contrast.\n\n    Attributes:\n        wavevector (NDArray[np.float64]): Array of wavevector values at which scattering properties are computed.\n        mixture (MixtureLike): `Mixture` object containing number fractions and radii of particle components.\n        particles (list): List of `Particle` instances representing the particles in the scattering model.\n\n    Methods:\n        __init__(wavevector, mixture, contrast):\n            Initializes a `SimpleSphere` instance with given wavevector, mixture, and contrast.\n\n    Usage:\n        The typical usage involves creating an instance of `SimpleSphere` with specific wavevector,\n        mixture, and contrast parameters, then using its inherited methods to compute scattering properties.\n\n    Example:\n        Initialize a `SimpleSphere` instance with wavevector, mixture, and contrast parameters:\n\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; from mixscatter import Mixture, SimpleSphere\n            &gt;&gt;&gt; wavevector = np.linspace(0.01, 1.0, 100)\n            &gt;&gt;&gt; mixture = Mixture(number_fraction=[0.5, 0.5], radius=[1.0, 2.0])\n            &gt;&gt;&gt; model = SimpleSphere(wavevector, mixture, contrast=1.0)\n            &gt;&gt;&gt; form_factor = model.average_form_factor\n\n    Notes:\n        - The particle radii are inferred from the provided `Mixture` instance.\n    \"\"\"\n\n    def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, contrast: float) -&gt; None:\n        \"\"\"\n        Initializes a `SimpleSphere` instance.\n\n        Args:\n            wavevector: Array of wavevector values at which scattering properties are computed.\n            mixture: `Mixture` object containing number fractions and radii of particle components.\n            contrast: Scattering contrast of the spheres.\n        \"\"\"\n        particles = []\n        particle_builder = ParticleBuilder()\n        for radius in mixture.radius:\n            particle = particle_builder.add_layer(ConstantProfile(0, radius, contrast)).pop_particle()\n            particles.append(particle)\n        super().__init__(wavevector, mixture, particles)\n</code></pre>"},{"location":"api/scatteringmodel_api/#mixscatter.scatteringmodel.SimpleSphere.__init__","title":"<code>__init__(wavevector, mixture, contrast)</code>","text":"<p>Initializes a <code>SimpleSphere</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>wavevector</code> <code>ArrayLike</code> <p>Array of wavevector values at which scattering properties are computed.</p> required <code>mixture</code> <code>MixtureLike</code> <p><code>Mixture</code> object containing number fractions and radii of particle components.</p> required <code>contrast</code> <code>float</code> <p>Scattering contrast of the spheres.</p> required Source code in <code>src/mixscatter/scatteringmodel/scatteringmodel.py</code> <pre><code>def __init__(self, wavevector: ArrayLike, mixture: MixtureLike, contrast: float) -&gt; None:\n    \"\"\"\n    Initializes a `SimpleSphere` instance.\n\n    Args:\n        wavevector: Array of wavevector values at which scattering properties are computed.\n        mixture: `Mixture` object containing number fractions and radii of particle components.\n        contrast: Scattering contrast of the spheres.\n    \"\"\"\n    particles = []\n    particle_builder = ParticleBuilder()\n    for radius in mixture.radius:\n        particle = particle_builder.add_layer(ConstantProfile(0, radius, contrast)).pop_particle()\n        particles.append(particle)\n    super().__init__(wavevector, mixture, particles)\n</code></pre>"},{"location":"getting_started/getting-started/","title":"Introduction","text":"<p>Welcome to the mixscatter Getting Started Guide! This guide will walk you through the basic functionalities of the package, showcasing its power and versatility in analyzing scattering experiments.</p>"},{"location":"getting_started/getting-started/#why-mixscatter","title":"Why mixscatter?","text":"<p>mixscatter is a comprehensive solution designed to tackle the complexities of analyzing  multi-component particle mixtures in scattering experiments. What sets mixscatter apart are  its three foundational concepts:</p> <ol> <li> <p>Mixture Composition: With mixscatter, you can define the composition of your     particle mixture with precision. Whether you're working with two components or ten, specifying     their sizes and relative abundances is straightforward. You can also create mixtures which     mimic the properties of continuous size distributions. </p> </li> <li> <p>Scattering Models: mixscatter enables you to define detailed scattering length     density profiles for each particle species independently, influencing single-particle scattering     amplitudes and overall form factors. Its flexible model-building capabilities allow for both     predefined simple models and more complex custom particles.</p> </li> <li> <p>Liquid Structure: mixscatter offers solutions for the analytic calculation    of partial structure factors. It also provides a seamless interface for incorporating externally     generated structure factors, ensuring versatility and adaptability.</p> </li> </ol>"},{"location":"getting_started/getting-started/#first-steps","title":"First Steps","text":"<p>Follow these steps to get to know the core functions of mixscatter:</p>"},{"location":"getting_started/getting-started/#step-1-import-necessary-modules","title":"Step 1: Import Necessary Modules","text":"<pre><code>import mixscatter as ms\nimport numpy as np\n</code></pre>"},{"location":"getting_started/getting-started/#step-2-create-a-mixture","title":"Step 2: Create a Mixture","text":"<p>Define the composition of your system using the <code>Mixture</code> object:</p> <pre><code>radii = [100, 200]\nnumber_fractions = [0.2, 0.8]\nmixture = ms.mixture.Mixture(radii, number_fractions)\n</code></pre>"},{"location":"getting_started/getting-started/#step-3-define-the-wavevector","title":"Step 3: Define the Wavevector","text":"<p>Set up the scattering wavevector grid for calculations:</p> <pre><code>wavevector = np.linspace(0.005, 0.05, 100)\n</code></pre>"},{"location":"getting_started/getting-started/#step-4-create-a-scattering-model","title":"Step 4: Create a Scattering Model","text":"<p>Construct a scattering model to represent your system:</p> <pre><code>scattering_model = ms.scatteringmodel.SimpleSphere(\n    wavevector, mixture, contrast=1.0\n)\n</code></pre>"},{"location":"getting_started/getting-started/#step-5-define-the-liquid-structure","title":"Step 5: Define the Liquid Structure","text":"<p>Specify the liquid structure of your system:</p> <pre><code>liquid_structure = ms.liquidstructure.PercusYevick(\n    wavevector, mixture, volume_fraction_total=0.3\n)\n</code></pre>"},{"location":"getting_started/getting-started/#step-6-calculate-measurable-quantities","title":"Step 6: Calculate Measurable Quantities","text":"<p>Now, let's compute some measurable quantities:</p>"},{"location":"getting_started/getting-started/#measurable-scattered-intensity","title":"Measurable Scattered Intensity","text":"<pre><code>intensity = ms.measurable_intensity(\n    liquid_structure, scattering_model, scale=1e5, background=1e3\n)\n</code></pre>"},{"location":"getting_started/getting-started/#measurable-structure-factor","title":"Measurable Structure Factor","text":"<pre><code>structure_factor = ms.measurable_structure_factor(\n    liquid_structure, scattering_model\n)\n</code></pre>"},{"location":"getting_started/getting-started/#measurable-diffusion-coefficient","title":"Measurable Diffusion Coefficient","text":"<pre><code>diffusion_coefficient = ms.measurable_diffusion_coefficient(\n    scattering_model, thermal_energy=1.0, viscosity=1.0\n)\n</code></pre>"},{"location":"getting_started/getting-started/#a-note-on-units-of-measurement","title":"A Note on Units of Measurement","text":"<p>mixscatter doesn't enforce any particular unit system. You have the flexibility to choose units of length, time, and energy that best suit your work. Just remember to maintain consistency throughout your analysis.</p>"},{"location":"getting_started/liquid-structure/","title":"Liquid Structure","text":"<p>The <code>liquidstructure</code> module provides tools to model the liquid structure properties of multicomponent systems of spherical particles. The primary functionality revolves around calculating various structure factors using different approximations. Currently, the following model classes are implemented:</p> <ul> <li>LiquidStructure: An   abstract base class representing the liquid structure properties of a multicomponent system.</li> <li>PercusYevick: A concrete class   implementing the hard-sphere potential in the Percus-Yevick approximation.</li> <li>VerletWeis: A subclass of   <code>PercusYevick</code> that employs the Verlet-Weiss correction.</li> </ul>"},{"location":"getting_started/liquid-structure/#example-usage","title":"Example usage","text":""},{"location":"getting_started/liquid-structure/#initialize-a-model","title":"Initialize a model","text":"<p>Create an instance of <code>PercusYevick</code> with the wavevector, mixture, and total volume fraction.</p> <pre><code>import numpy as np\nfrom mixscatter.liquidstructure import PercusYevick\nfrom mixscatter.mixture import Mixture\n\nwavevector = np.linspace(0.01, 1, 100)\nmixture = Mixture([5.0, 10.0], [0.5, 0.5])\nvolume_fraction_total = 0.3\n\n# Initialize the PercusYevick model\npy_model = PercusYevick(wavevector, mixture, volume_fraction_total)\n</code></pre>"},{"location":"getting_started/liquid-structure/#calculate-structure-factors","title":"Calculate Structure Factors","text":"<p>Use the properties of the <code>PercusYevick</code> class to calculate  various structure factors and related quantities:</p> <pre><code># Partial direct correlation function\npartial_direct_correlation = py_model.partial_direct_correlation_function\n\n# Number-weighted partial direct correlation function\nnumber_weighted_direct_correlation = py_model.number_weighted_partial_direct_correlation_function\n\n# Partial structure factor\npartial_structure_factor = py_model.partial_structure_factor\n\n# Number-weighted partial structure factor\nnumber_weighted_structure_factor = py_model.number_weighted_partial_structure_factor\n\n# Average structure factor\naverage_structure_factor = py_model.average_structure_factor\n\n# Compressibility structure factor\ncompressibility_structure_factor = py_model.compressibility_structure_factor\n</code></pre>"},{"location":"getting_started/liquid-structure/#provide-external-structure-factors","title":"Provide external structure factors","text":"<p>Say you have an external dataset of partial structure factors \\(S_{\\alpha\\beta}(Q)\\) as a function of  the wavevector \\(Q\\), for example, from a computer simulation. You can easily use these structure  factors in mixscatter.</p> <p>To be used in the functions <code>measurable_intensity</code> and <code>measurable_structure_factor</code>, you have to provide an object with an interface which follows the  <code>LiquidStructureLike</code> protocol. <pre><code>class LiquidStructureLike(Protocol):\n    \"\"\"A protocol which defines an interface for a class which behaves like LiquidStructure\"\"\"\n    @property\n    def number_weighted_partial_structure_factor(self) -&gt; NDArray[np.float64]: ...\n</code></pre></p> <p>The only thing this object needs is a property named <code>number_weighted_partial_structure_factor</code>  which must be a numpy array of type <code>float</code> with the shape (N, N, M), where N is the number  of components and M the size of the wavevector array. 'Number weighted partial structure factor'  means that the partial structure factors follow the convention \\(S_{\\alpha\\beta}(Q\\to\\infty) =  x_\\alpha \\delta_{\\alpha\\beta}\\), where \\(x_\\alpha\\) is the number fraction and \\(\\delta_{\\alpha\\beta}\\) is the Kronecker symbol.</p> <p>This can be as simple as  <pre><code>my_structure_factors = ... # Assume a numpy array of correct type, shape, and values\n\nclass MyLiquidStructure:\n    def __init__(self, structure_factor_input):\n        self.number_weighted_partial_structure_factor = structure_factor_input\n\nmy_liquid_structure = MyLiquidStructure(my_structure_factors)\n\n\n# Calculate scattered intensity\nintensity = measurable_intensity(my_liquid_structure, scattering_model)\n</code></pre></p> <p>If your partial structure factors follow the convention \\(\\tilde{S}_{\\alpha\\beta}(Q\\to\\infty) =  \\delta_{\\alpha\\beta}\\) and are not already weighted by the number fraction, an easy way to  convert conventions is by using <code>numpy.einsum</code> and calculating  \\(S_{\\alpha\\beta}(Q) = (x_\\alpha x_\\beta)^{1/2} \\tilde{S}_{\\alpha\\beta}(Q)\\): <pre><code>unweighted_structure_factors = ... # numpy array of shape (N, N, M)\nnumber_fractions = ... # numpy array of shape (N, )\n\nnumber_weighted_structure_factors = np.einsum(\n  \"i, j, ijq-&gt;ijq\",\n  np.sqrt(number_fractions),\n  np.sqrt(number_fractions),\n  unweighted_structure_factors\n)\n</code></pre></p>"},{"location":"getting_started/mixtures/","title":"Mixtures","text":"<p>The <code>mixture</code> module provides tools to  represent and manipulate mixtures of spherical particles with various size distributions.</p>"},{"location":"getting_started/mixtures/#creating-a-mixture","title":"Creating a Mixture","text":"<p>To create a mixture, you can use the <code>Mixture</code> class directly or use one of the convenience classes provided for specific distributions. Here are some examples:</p>"},{"location":"getting_started/mixtures/#binary-mixture","title":"Binary Mixture","text":"<p>Manually create a 50:50 binary mixture of two species with radii 100 and 250, respectively:</p> <pre><code>from mixscatter.mixture import Mixture\n\nbinary_mixture = Mixture(radius=[100, 250], number_fraction=[0.5, 0.5])\n</code></pre>"},{"location":"getting_started/mixtures/#monodisperse-system","title":"Monodisperse System","text":"<p>Create a pseudo-mixture representing a monodisperse system with a radius of 500:</p> <pre><code>from mixscatter.mixture import SingleComponent\n\nmonodisperse_system = SingleComponent(radius=500)\n</code></pre>"},{"location":"getting_started/mixtures/#flory-schulz-distribution","title":"Flory-Schulz Distribution","text":"<p>Specifically, a Gamma distribution (often termed Schulz/Flory/Zimm-distribution depending on the scientific community), with probability density function</p> \\[ P(R) = \\frac{1}{\\Gamma(Z+1)} \\left(  \\frac{Z+1}{\\langle R \\rangle} \\right)^{Z+1} R^Z \\exp\\left( -\\frac{Z+1}{\\langle R \\rangle} R \\right), \\] <p>with mean radius \\(\\langle R \\rangle\\) and variance \\(\\langle R^2 \\rangle - \\langle R \\rangle^2 =\\langle R \\rangle^2/(Z+1)\\). \\(Z\\) is also called shape parameter.</p> <p>Create a mixture approximating a Schulz-Flory distribution with a mean radius of 100 and a shape parameter of 99:</p> <pre><code>from mixscatter.mixture import FlorySchulzMixture\n\nflory_mixture = FlorySchulzMixture(\n    number_of_components=16, mean_radius=100, shape_parameter=99)\n</code></pre> <p>The approximation is based on generalized Gauss-Laguerre quadrature.</p>"},{"location":"getting_started/mixtures/#gaussian-distribution","title":"Gaussian Distribution","text":"<p>Gaussian or normal distribution with probability density function</p> \\[ P(R) = \\frac{1}{\\sigma\\sqrt{(2\\pi)}} \\exp  \\left[ - \\dfrac{1}{2} \\left(\\frac{R-\\langle R \\rangle} {\\sigma}\\right) ^2 \\right], \\] <p>with mean radius \\(\\langle R \\rangle\\) and standard deviation \\(\\sigma\\).</p> <p>Create a mixture approximating a Gaussian distribution with a mean radius of 100 and a standard deviation of 10:</p> <pre><code>from mixscatter.mixture import GaussianMixture\n\ngaussian_mixture = GaussianMixture(\n    number_of_components=16, mean_radius=100, standard_deviation=10)\n</code></pre> <p>The approximation is based on Gauss-Hermite quadrature.</p>"},{"location":"getting_started/mixtures/#uniform-distribution","title":"Uniform Distribution","text":"<p>Continuous uniform distribution with probability density function</p> \\[ P(R) = \\left\\{ \\begin{array}{ll} \\dfrac{1}{b-a} &amp; a \\leq R \\leq b \\\\ 0 &amp; \\, \\textrm{otherwise} \\\\ \\end{array} \\right. \\] <p>with lower bound \\(a\\) and upper bound \\(b\\).</p> <p>Create a mixture approximating a uniform distribution between radii 50 and 150:</p> <pre><code>from mixscatter.mixture import UniformMixture\n\nuniform_mixture = UniformMixture(\n    number_of_components=16, lower_bound=50, upper_bound=150)\n</code></pre> <p>The approximation is based on Gauss-Legendre quadrature.</p>"},{"location":"getting_started/mixtures/#accessing-mixture-properties","title":"Accessing Mixture Properties","text":"<p>You can access various properties of a mixture, such as the mean radius and polydispersity:</p> <pre><code>print(f\"Mean radius: {flory_mixture.mean}\")\nprint(f\"Polydispersity: {flory_mixture.polydispersity}\")\n</code></pre> <p>See the API Reference for a full list of  available attributes and methods.</p>"},{"location":"getting_started/scattering-models/","title":"Scattering Models","text":"<p>The <code>scatteringmodel</code> module  provides tools to calculate scattering amplitudes and form factors of multicomponent systems  consisting of spherical particles.</p>"},{"location":"getting_started/scattering-models/#overview","title":"Overview","text":""},{"location":"getting_started/scattering-models/#particles-and-layers","title":"Particles and Layers","text":"<p>Particles are represented by <code>Particle</code> objects composed of layers, each represented by a specific scattering length density profile. These layers can have different scattering properties, which are defined by the <code>LayerProfile</code> interface. The module includes several predefined layer profiles:</p> <ul> <li>EmptyProfile: Represents an   empty layer.</li> <li>ConstantProfile: Represents a   layer with constant contrast.</li> <li>LinearProfile: Represents a   layer with linearly varying contrast.</li> </ul>"},{"location":"getting_started/scattering-models/#particlebuilder","title":"ParticleBuilder","text":"<p>The <code>ParticleBuilder</code> class is a utility to help construct particles layer by layer. Once the desired layers are added, a <code>Particle</code> instance can be created.</p>"},{"location":"getting_started/scattering-models/#scatteringmodel","title":"ScatteringModel","text":"<p>The <code>ScatteringModel</code> class calculates scattering properties for a list of particles. It can compute various properties such as scattering amplitudes, forward scattering amplitudes, and form factors.</p>"},{"location":"getting_started/scattering-models/#convenience-classes","title":"Convenience Classes","text":"<p>There are several convenience classes provided to quickly create models for common scenarios from a given particle mixture:</p> <ul> <li>SimpleSphere: For a mixture of   homogeneously scattering spheres.</li> <li>SimpleCoreShell: For a   mixture of core-shell particles with a common core-to-shell ratio.</li> <li>SimpleGradient: For a mixture of   particles displaying a linear gradient of the scattering length density.</li> </ul>"},{"location":"getting_started/scattering-models/#example-usage","title":"Example Usage","text":""},{"location":"getting_started/scattering-models/#using-particlebuilder-to-construct-particles","title":"Using <code>ParticleBuilder</code> to Construct Particles","text":"<p>The <code>ParticleBuilder</code> class is used to construct particles by adding layers. Here\u2019s an example of how to use it:</p> <pre><code>from mixscatter.scatteringmodel import (\n    ParticleBuilder, ConstantProfile, LinearProfile\n)\n\n# Create a ParticleBuilder instance\nbuilder = ParticleBuilder()\n\n# Add a layer to the builder\nbuilder.add_layer(ConstantProfile(0, 10, 1.0))\n\n# Add another layer to the builder\nbuilder.add_layer(LinearProfile(10, 20, 1.0, 0.0))\n\n# Get the constructed particle\nparticle = builder.get_particle()\n</code></pre> <p>You can do the construction in a single command by chaining the operations like this: <pre><code>builder = ParticleBuilder()\nparticle = (\n            builder\n            .add_layer(ConstantProfile(0, 10, 1.0))\n            .add_layer(LinearProfile(10, 20, 1.0, 0.0))\n            .get_particle()\n           )\n</code></pre></p>"},{"location":"getting_started/scattering-models/#accessing-single-particle-properties","title":"Accessing Single-Particle Properties","text":"<p>The <code>Particle</code> class provides methods for displaying the scattering length density profile and for calculating the scattering amplitude and  the form factor of a single constructed particle:</p> <pre><code>profile = particle.get_profile(distance)\n\namplitude = particle.calculate_amplitude(wavevector)\n\nforward_amplitude = particle.calculate_forward_amplitude()\n\nform_factor = particle.calculate_form_factor(wavevector)\n\nsquare_radius_of_gyration = particle.calculate_square_radius_of_gyration()\n</code></pre>"},{"location":"getting_started/scattering-models/#using-scatteringmodel","title":"Using <code>ScatteringModel</code>","text":"<p>The <code>ScatteringModel</code> class calculates the scattering properties from a list of particles and a matching <code>Mixture</code> instance. Here\u2019s an example of how to use it:</p> <pre><code>import numpy as np\nfrom mixscatter.scatteringmodel import (\n    ScatteringModel, ParticleBuilder, ConstantProfile\n)\nfrom mixscatter.mixture import Mixture\n\nmixture = Mixture(radius=[1.0, 2.0], number_fraction=[0.5, 0.5])\n\n# Create particles using ParticleBuilder\nbuilder = ParticleBuilder()\n# pop_particle() obtains the constructed particle and then resets the builder\nparticles = [\n    builder.add_layer(ConstantProfile(0, radius, 1.0)).pop_particle()\n    for radius in mixture.radius\n    ]\n\n# Create a ScatteringModel instance\nwavevector = np.linspace(0.01, 1.0, 100)\nmodel = ScatteringModel(wavevector, mixture, particles)\n\n# Calculate the average form factor\nform_factor = model.average_form_factor\n</code></pre> <p>A <code>ScatteringModel</code> can contain almost any conceivable combination of particles with  totally different optical properties. This flexibility makes the tool particularly powerful.</p>"},{"location":"getting_started/scattering-models/#convenience-classes_1","title":"Convenience Classes","text":"<p>The module includes several convenience classes to quickly create models for common particle types:</p>"},{"location":"getting_started/scattering-models/#simplesphere","title":"SimpleSphere","text":"<pre><code>from mixscatter.scatteringmodel import SimpleSphere\n\n# Create a simple sphere model\nmodel = SimpleSphere(wavevector, mixture, contrast=1.0)\nform_factor = model.average_form_factor\n</code></pre>"},{"location":"getting_started/scattering-models/#simplecoreshell","title":"SimpleCoreShell","text":"<pre><code>from mixscatter.scatteringmodel import SimpleCoreShell\n\n# Create a core-shell model\nmodel = SimpleCoreShell(\n    wavevector,\n    mixture,\n    core_to_total_ratio=0.5,\n    core_contrast=1.0,\n    shell_contrast=0.5\n    )\nform_factor = model.average_form_factor\n</code></pre>"},{"location":"getting_started/scattering-models/#simplegradient","title":"SimpleGradient","text":"<pre><code>from mixscatter.scatteringmodel import SimpleGradient\n\n# Create a gradient profile model\nmodel = SimpleGradient(\n    wavevector, mixture, center_contrast=1.0, boundary_contrast=0.5\n    )\nform_factor = model.average_form_factor\n</code></pre>"},{"location":"getting_started/scattering-models/#implementing-your-own-model","title":"Implementing Your Own Model","text":"<p>To implement your own layer profile or scattering model from scratch, you can extend the <code>LayerProfile</code> and the <code>ScatteringModel</code> class. Here\u2019s a basic example:</p> <pre><code>from mixscatter.scatteringmodel import (\n    ScatteringModel, ParticleBuilder, LayerProfile\n    )\nimport numpy as np\n\nclass CustomProfile(LayerProfile):\n    def __init__(self, radius_inner, radius_outer, custom_param):\n        self.radius_inner = radius_inner\n        self.radius_outer = radius_outer\n        self.custom_param = custom_param\n\n    def calculate_amplitude(self, wavevector):\n        wavevector = np.asarray(wavevector)\n        # Custom amplitude calculation logic\n        amplitude = ...  # Replace with actual calculation\n        return amplitude\n\n    def calculate_forward_amplitude(self):\n        # Custom forward amplitude calculation logic\n        forward_amplitude = ...  # Replace with actual calculation\n        return forward_amplitude\n\n    def get_profile(self, distance):\n        distance = np.asarray(distance)\n        # Custom profile calculation logic\n        profile = ... # Replace with actual calculation\n        return profile\n\nclass CustomModel(ScatteringModel):\n    def __init__(self, wavevector, mixture, custom_param):\n        particles = []\n        particle_builder = ParticleBuilder()\n        for radius in mixture.radius:\n            particle = (\n            particle_builder\n            .add_layer(CustomProfile(0, radius, custom_param))\n            # Add as many layers as you want\n            .pop_particle()\n            )\n            particles.append(particle)\n        super().__init__(wavevector, mixture, particles)\n\n# Using the custom model\ncustom_param = 1.0\nmodel = CustomModel(wavevector, mixture, custom_param)\nform_factor = model.average_form_factor\n</code></pre>"}]}